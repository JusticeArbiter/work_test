--
-- ALTER_TABLE
-- add attribute
--
CREATE TABLE tmp (initial int4);
CREATE TABLE
COMMENT ON TABLE tmp_wrong IS 'table comment';
ERROR:  42P01: relation "tmp_wrong" does not exist
COMMENT ON TABLE tmp IS 'table comment';
COMMENT
COMMENT ON TABLE tmp IS NULL;
COMMENT
ALTER TABLE tmp ADD COLUMN xmin integer; -- fails
ERROR:  42701: column name "xmin" conflicts with a system column name
ALTER TABLE tmp ADD COLUMN a int4 default 3;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN b name;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN c text;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN d float8;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN e float4;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN f int2;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN g polygon;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN h abstime;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN i char;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN j abstime[];
ALTER TABLE
ALTER TABLE tmp ADD COLUMN k int4;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN l tid;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN m xid;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN n oidvector;
ALTER TABLE
--ALTER TABLE tmp ADD COLUMN o lock;
ALTER TABLE tmp ADD COLUMN p smgr;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN q point;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN r lseg;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN s path;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN t box;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN u tinterval;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN v timestamp;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN w interval;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN x float8[];
ALTER TABLE
ALTER TABLE tmp ADD COLUMN y float4[];
ALTER TABLE
ALTER TABLE tmp ADD COLUMN z int2[];
ALTER TABLE
INSERT INTO tmp (a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u,
	v, w, x, y, z)
   VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
        'Mon May  1 00:30:30 1995', 'c', '{Mon May  1 00:30:30 1995, Monday Aug 24 14:43:07 1992, epoch}',
	314159, '(1,1)', '512',
	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
INSERT 0 1
SELECT * FROM tmp;
 initial | a |  b   |  c   |  d  |  e  | f |           g           |           h            | i |                                      j                                       |   k    |   l   |  m  |        n        |       p       |     q     |           r           |              s              |          t          |                   u                   |          v          |    w     |     x     |     y     |     z     
---------+---+------+------+-----+-----+---+-----------------------+------------------------+---+------------------------------------------------------------------------------+--------+-------+-----+-----------------+---------------+-----------+-----------------------+-----------------------------+---------------------+---------------------------------------+---------------------+----------+-----------+-----------+-----------
         | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | 1995-05-01 00:30:30+08 | c | {"1995-05-01 00:30:30+08","1992-08-24 14:43:07+08","1970-01-01 08:00:00+08"} | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | magnetic disk | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | ["1970-01-01 08:00:00+08" "infinity"] | 1970-01-01 00:00:00 | 01:00:10 | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
(1 row)

DROP TABLE tmp;
DROP TABLE
-- the wolf bug - schema mods caused inconsistent row descriptors
CREATE TABLE tmp (
	initial 	int4
);
CREATE TABLE
ALTER TABLE tmp ADD COLUMN a int4;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN b name;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN c text;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN d float8;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN e float4;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN f int2;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN g polygon;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN h abstime;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN i char;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN j abstime[];
ALTER TABLE
ALTER TABLE tmp ADD COLUMN k int4;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN l tid;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN m xid;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN n oidvector;
ALTER TABLE
--ALTER TABLE tmp ADD COLUMN o lock;
ALTER TABLE tmp ADD COLUMN p smgr;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN q point;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN r lseg;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN s path;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN t box;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN u tinterval;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN v timestamp;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN w interval;
ALTER TABLE
ALTER TABLE tmp ADD COLUMN x float8[];
ALTER TABLE
ALTER TABLE tmp ADD COLUMN y float4[];
ALTER TABLE
ALTER TABLE tmp ADD COLUMN z int2[];
ALTER TABLE
INSERT INTO tmp (a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u,
	v, w, x, y, z)
   VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
        'Mon May  1 00:30:30 1995', 'c', '{Mon May  1 00:30:30 1995, Monday Aug 24 14:43:07 1992, epoch}',
	314159, '(1,1)', '512',
	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
INSERT 0 1
SELECT * FROM tmp;
 initial | a |  b   |  c   |  d  |  e  | f |           g           |           h            | i |                                      j                                       |   k    |   l   |  m  |        n        |       p       |     q     |           r           |              s              |          t          |                   u                   |          v          |    w     |     x     |     y     |     z     
---------+---+------+------+-----+-----+---+-----------------------+------------------------+---+------------------------------------------------------------------------------+--------+-------+-----+-----------------+---------------+-----------+-----------------------+-----------------------------+---------------------+---------------------------------------+---------------------+----------+-----------+-----------+-----------
         | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | 1995-05-01 00:30:30+08 | c | {"1995-05-01 00:30:30+08","1992-08-24 14:43:07+08","1970-01-01 08:00:00+08"} | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | magnetic disk | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | ["1970-01-01 08:00:00+08" "infinity"] | 1970-01-01 00:00:00 | 01:00:10 | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
(1 row)

DROP TABLE tmp;
DROP TABLE
--
-- rename - check on both non-temp and temp tables
--
CREATE TABLE tmp (regtable int);
CREATE TABLE
CREATE TEMP TABLE tmp (tmptable int);
CREATE TABLE
ALTER TABLE tmp RENAME TO tmp_new;
ALTER TABLE
SELECT * FROM tmp;
 regtable 
----------
(0 rows)

SELECT * FROM tmp_new;
 tmptable 
----------
(0 rows)

ALTER TABLE tmp RENAME TO tmp_new2;
ALTER TABLE
SELECT * FROM tmp;		-- should fail
ERROR:  42P01: relation "tmp" does not exist
LINE 1: SELECT * FROM tmp;
                      ^
SELECT * FROM tmp_new;
 tmptable 
----------
(0 rows)

SELECT * FROM tmp_new2;
 regtable 
----------
(0 rows)

DROP TABLE tmp_new;
DROP TABLE
DROP TABLE tmp_new2;
DROP TABLE
--
-- check renaming to a table's array type's autogenerated name
-- (the array type's name should get out of the way)
--
CREATE TABLE tmp_array (id int);
CREATE TABLE
CREATE TABLE tmp_array2 (id int);
CREATE TABLE
SELECT typname FROM pg_type WHERE oid = 'tmp_array[]'::regtype;
  typname   
------------
 _tmp_array
(1 row)

SELECT typname FROM pg_type WHERE oid = 'tmp_array2[]'::regtype;
   typname   
-------------
 _tmp_array2
(1 row)

ALTER TABLE tmp_array2 RENAME TO _tmp_array;
ALTER TABLE
SELECT typname FROM pg_type WHERE oid = 'tmp_array[]'::regtype;
   typname   
-------------
 __tmp_array
(1 row)

SELECT typname FROM pg_type WHERE oid = '_tmp_array[]'::regtype;
   typname    
--------------
 ___tmp_array
(1 row)

DROP TABLE _tmp_array;
DROP TABLE
DROP TABLE tmp_array;
DROP TABLE
-- renaming to table's own array type's name is an interesting corner case
CREATE TABLE tmp_array (id int);
CREATE TABLE
SELECT typname FROM pg_type WHERE oid = 'tmp_array[]'::regtype;
  typname   
------------
 _tmp_array
(1 row)

ALTER TABLE tmp_array RENAME TO _tmp_array;
ALTER TABLE
SELECT typname FROM pg_type WHERE oid = '_tmp_array[]'::regtype;
   typname   
-------------
 __tmp_array
(1 row)

DROP TABLE _tmp_array;
DROP TABLE
-- ALTER TABLE ... RENAME on non-table relations
-- renaming indexes (FIXME: this should probably test the index's functionality)
ALTER INDEX IF EXISTS __onek_unique1 RENAME TO tmp_onek_unique1;
NOTICE:  00000: relation "__onek_unique1" does not exist, skipping
ALTER INDEX
ALTER INDEX IF EXISTS __tmp_onek_unique1 RENAME TO onek_unique1;
NOTICE:  00000: relation "__tmp_onek_unique1" does not exist, skipping
ALTER INDEX
ALTER INDEX onek_unique1 RENAME TO tmp_onek_unique1;
ALTER INDEX
ALTER INDEX tmp_onek_unique1 RENAME TO onek_unique1;
ALTER INDEX
-- renaming views
CREATE VIEW tmp_view (unique1) AS SELECT unique1 FROM tenk1;
CREATE VIEW
ALTER TABLE tmp_view RENAME TO tmp_view_new;
ALTER TABLE
-- hack to ensure we get an indexscan here
set enable_seqscan to off;
SET
set enable_bitmapscan to off;
SET
-- 5 values, sorted
SELECT unique1 FROM tenk1 WHERE unique1 < 5;
 unique1 
---------
(0 rows)

reset enable_seqscan;
RESET
reset enable_bitmapscan;
RESET
DROP VIEW tmp_view_new;
DROP VIEW
-- toast-like relation name
alter table stud_emp rename to pg_toast_stud_emp;
ALTER TABLE
alter table pg_toast_stud_emp rename to stud_emp;
ALTER TABLE
-- renaming index should rename constraint as well
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
ALTER TABLE
ALTER INDEX onek_unique1_constraint RENAME TO onek_unique1_constraint_foo;
ALTER INDEX
ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
ALTER TABLE
-- renaming constraint
ALTER TABLE onek ADD CONSTRAINT onek_check_constraint CHECK (unique1 >= 0);
ALTER TABLE
ALTER TABLE onek RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo;
ALTER TABLE
ALTER TABLE onek DROP CONSTRAINT onek_check_constraint_foo;
ALTER TABLE
-- renaming constraint should rename index as well
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
ALTER TABLE
DROP INDEX onek_unique1_constraint;  -- to see whether it's there
ERROR:  2BP01: cannot drop index onek_unique1_constraint because constraint onek_unique1_constraint on table onek requires it
HINT:  You can drop constraint onek_unique1_constraint on table onek instead.
ALTER TABLE onek RENAME CONSTRAINT onek_unique1_constraint TO onek_unique1_constraint_foo;
ALTER TABLE
DROP INDEX onek_unique1_constraint_foo;  -- to see whether it's there
ERROR:  2BP01: cannot drop index onek_unique1_constraint_foo because constraint onek_unique1_constraint_foo on table onek requires it
HINT:  You can drop constraint onek_unique1_constraint_foo on table onek instead.
ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
ALTER TABLE
-- renaming constraints vs. inheritance
CREATE TABLE constraint_rename_test (a int CONSTRAINT con1 CHECK (a > 0), b int, c int);
CREATE TABLE
\d constraint_rename_test
Table "public.constraint_rename_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 
 c      | integer | 
Check constraints:
    "con1" CHECK (a > 0)

CREATE TABLE constraint_rename_test2 (a int CONSTRAINT con1 CHECK (a > 0), d int) INHERITS (constraint_rename_test);
NOTICE:  00000: merging column "a" with inherited definition
NOTICE:  00000: merging constraint "con1" with inherited definition
CREATE TABLE
\d constraint_rename_test2
Table "public.constraint_rename_test2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 
 c      | integer | 
 d      | integer | 
Check constraints:
    "con1" CHECK (a > 0)
Inherits: constraint_rename_test

ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo; -- fail
ERROR:  42P16: cannot rename inherited constraint "con1"
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- fail
ERROR:  42P16: inherited constraint "con1" must be renamed in child tables too
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- ok
ALTER TABLE
\d constraint_rename_test
Table "public.constraint_rename_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 
 c      | integer | 
Check constraints:
    "con1foo" CHECK (a > 0)

\d constraint_rename_test2
Table "public.constraint_rename_test2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 
 c      | integer | 
 d      | integer | 
Check constraints:
    "con1foo" CHECK (a > 0)
Inherits: constraint_rename_test

ALTER TABLE constraint_rename_test ADD CONSTRAINT con2 CHECK (b > 0) NO INHERIT;
ALTER TABLE
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con2 TO con2foo; -- ok
ALTER TABLE
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con2foo TO con2bar; -- ok
ALTER TABLE
\d constraint_rename_test
Table "public.constraint_rename_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 
 c      | integer | 
Check constraints:
    "con1foo" CHECK (a > 0)
    "con2bar" CHECK (b > 0) NO INHERIT

\d constraint_rename_test2
Table "public.constraint_rename_test2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 
 c      | integer | 
 d      | integer | 
Check constraints:
    "con1foo" CHECK (a > 0)
Inherits: constraint_rename_test

ALTER TABLE constraint_rename_test ADD CONSTRAINT con3 PRIMARY KEY (a);
ALTER TABLE
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con3 TO con3foo; -- ok
ALTER TABLE
\d constraint_rename_test
Table "public.constraint_rename_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | not null
 b      | integer | 
 c      | integer | 
Indexes:
    "con3foo" PRIMARY KEY, btree (a)
Check constraints:
    "con1foo" CHECK (a > 0)
    "con2bar" CHECK (b > 0) NO INHERIT

\d constraint_rename_test2
Table "public.constraint_rename_test2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 
 c      | integer | 
 d      | integer | 
Check constraints:
    "con1foo" CHECK (a > 0)
Inherits: constraint_rename_test

DROP TABLE constraint_rename_test2;
DROP TABLE
DROP TABLE constraint_rename_test;
DROP TABLE
ALTER TABLE IF EXISTS constraint_not_exist RENAME CONSTRAINT con3 TO con3foo; -- ok
NOTICE:  00000: relation "constraint_not_exist" does not exist, skipping
ALTER TABLE
ALTER TABLE IF EXISTS constraint_rename_test ADD CONSTRAINT con4 UNIQUE (a);
NOTICE:  00000: relation "constraint_rename_test" does not exist, skipping
ALTER TABLE
-- FOREIGN KEY CONSTRAINT adding TEST
CREATE TABLE tmp2 (a int primary key);
CREATE TABLE
CREATE TABLE tmp3 (a int, b int);
CREATE TABLE
CREATE TABLE tmp4 (a int, b int, unique(a,b));
CREATE TABLE
CREATE TABLE tmp5 (a int, b int);
CREATE TABLE
-- Insert rows into tmp2 (pktable)
INSERT INTO tmp2 values (1);
INSERT 0 1
INSERT INTO tmp2 values (2);
INSERT 0 1
INSERT INTO tmp2 values (3);
INSERT 0 1
INSERT INTO tmp2 values (4);
INSERT 0 1
-- Insert rows into tmp3
INSERT INTO tmp3 values (1,10);
INSERT 0 1
INSERT INTO tmp3 values (1,20);
INSERT 0 1
INSERT INTO tmp3 values (5,50);
INSERT 0 1
-- Try (and fail) to add constraint due to invalid source columns
ALTER TABLE tmp3 add constraint tmpconstr foreign key(c) references tmp2 match full;
ERROR:  42703: column "c" referenced in foreign key constraint does not exist
-- Try (and fail) to add constraint due to invalid destination columns explicitly given
ALTER TABLE tmp3 add constraint tmpconstr foreign key(a) references tmp2(b) match full;
ERROR:  42703: column "b" referenced in foreign key constraint does not exist
-- Try (and fail) to add constraint due to invalid data
ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full;
ERROR:  23503: insert or update on table "tmp3" violates foreign key constraint "tmpconstr"
DETAIL:  Key (a)=(5) is not present in table "tmp2".
-- Delete failing row
DELETE FROM tmp3 where a=5;
DELETE 1
-- Try (and succeed)
ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full;
ALTER TABLE
ALTER TABLE tmp3 drop constraint tmpconstr;
ALTER TABLE
INSERT INTO tmp3 values (5,50);
INSERT 0 1
-- Try NOT VALID and then VALIDATE CONSTRAINT, but fails. Delete failure then re-validate
ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full NOT VALID;
ALTER TABLE
ALTER TABLE tmp3 validate constraint tmpconstr;
ERROR:  23503: insert or update on table "tmp3" violates foreign key constraint "tmpconstr"
DETAIL:  Key (a)=(5) is not present in table "tmp2".
-- Delete failing row
DELETE FROM tmp3 where a=5;
DELETE 1
-- Try (and succeed) and repeat to show it works on already valid constraint
ALTER TABLE tmp3 validate constraint tmpconstr;
ALTER TABLE
ALTER TABLE tmp3 validate constraint tmpconstr;
ALTER TABLE
-- Try a non-verified CHECK constraint
ALTER TABLE tmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10); -- fail
ERROR:  23514: check constraint "b_greater_than_ten" is violated by some row
ALTER TABLE tmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10) NOT VALID; -- succeeds
ALTER TABLE
ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- fails
ERROR:  23514: check constraint "b_greater_than_ten" is violated by some row
DELETE FROM tmp3 WHERE NOT b > 10;
DELETE 1
ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
ALTER TABLE
ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
ALTER TABLE
-- Test inherited NOT VALID CHECK constraints
select * from tmp3;
 a | b  
---+----
 1 | 20
(1 row)

CREATE TABLE tmp6 () INHERITS (tmp3);
CREATE TABLE
CREATE TABLE tmp7 () INHERITS (tmp3);
CREATE TABLE
INSERT INTO tmp6 VALUES (6, 30), (7, 16);
INSERT 0 2
ALTER TABLE tmp3 ADD CONSTRAINT b_le_20 CHECK (b <= 20) NOT VALID;
ALTER TABLE
ALTER TABLE tmp3 VALIDATE CONSTRAINT b_le_20;	-- fails
ERROR:  23514: check constraint "b_le_20" is violated by some row
DELETE FROM tmp6 WHERE b > 20;
DELETE 1
ALTER TABLE tmp3 VALIDATE CONSTRAINT b_le_20;	-- succeeds
ALTER TABLE
-- An already validated constraint must not be revalidated
CREATE FUNCTION boo(int) RETURNS int IMMUTABLE STRICT LANGUAGE plpgsql AS $$ BEGIN RAISE NOTICE 'boo: %', $1; RETURN $1; END; $$;
CREATE FUNCTION
INSERT INTO tmp7 VALUES (8, 18);
INSERT 0 1
ALTER TABLE tmp7 ADD CONSTRAINT identity CHECK (b = boo(b));
NOTICE:  00000: boo: 18
ALTER TABLE
ALTER TABLE tmp3 ADD CONSTRAINT IDENTITY check (b = boo(b)) NOT VALID;
NOTICE:  00000: merging constraint "identity" with inherited definition
ALTER TABLE
ALTER TABLE tmp3 VALIDATE CONSTRAINT identity;
NOTICE:  00000: boo: 16
NOTICE:  00000: boo: 20
ALTER TABLE
-- A NO INHERIT constraint should not be looked for in children during VALIDATE CONSTRAINT
create table parent_noinh_convalid (a int);
CREATE TABLE
create table child_noinh_convalid () inherits (parent_noinh_convalid);
CREATE TABLE
insert into parent_noinh_convalid values (1);
INSERT 0 1
insert into child_noinh_convalid values (1);
INSERT 0 1
alter table parent_noinh_convalid add constraint check_a_is_2 check (a = 2) no inherit not valid;
ALTER TABLE
-- fail, because of the row in parent
alter table parent_noinh_convalid validate constraint check_a_is_2;
ERROR:  23514: check constraint "check_a_is_2" is violated by some row
delete from only parent_noinh_convalid;
DELETE 1
-- ok (parent itself contains no violating rows)
alter table parent_noinh_convalid validate constraint check_a_is_2;
ALTER TABLE
select convalidated from pg_constraint where conrelid = 'parent_noinh_convalid'::regclass and conname = 'check_a_is_2';
 convalidated 
--------------
 t
(1 row)

-- cleanup
drop table parent_noinh_convalid, child_noinh_convalid;
DROP TABLE
-- Try (and fail) to create constraint from tmp5(a) to tmp4(a) - unique constraint on
-- tmp4 is a,b
ALTER TABLE tmp5 add constraint tmpconstr foreign key(a) references tmp4(a) match full;
ERROR:  42830: there is no unique constraint matching given keys for referenced table "tmp4"
DROP TABLE tmp7;
DROP TABLE
DROP TABLE tmp6;
DROP TABLE
DROP TABLE tmp5;
DROP TABLE
DROP TABLE tmp4;
DROP TABLE
DROP TABLE tmp3;
DROP TABLE
DROP TABLE tmp2;
DROP TABLE
-- NOT VALID with plan invalidation -- ensure we don't use a constraint for
-- exclusion until validated
set constraint_exclusion TO 'partition';
SET
create table nv_parent (d date);
CREATE TABLE
create table nv_child_2010 () inherits (nv_parent);
CREATE TABLE
create table nv_child_2011 () inherits (nv_parent);
CREATE TABLE
alter table nv_child_2010 add check (d between '2010-01-01'::date and '2010-12-31'::date) not valid;
ALTER TABLE
alter table nv_child_2011 add check (d between '2011-01-01'::date and '2011-12-31'::date) not valid;
ALTER TABLE
explain (costs off) select * from nv_parent where d between '2011-08-01' and '2011-08-31';
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Seq Scan on nv_parent
         Filter: ((d >= '2011-08-01'::date) AND (d <= '2011-08-31'::date))
   ->  Seq Scan on nv_child_2010
         Filter: ((d >= '2011-08-01'::date) AND (d <= '2011-08-31'::date))
   ->  Seq Scan on nv_child_2011
         Filter: ((d >= '2011-08-01'::date) AND (d <= '2011-08-31'::date))
(7 rows)

create table nv_child_2009 (check (d between '2009-01-01'::date and '2009-12-31'::date)) inherits (nv_parent);
CREATE TABLE
explain (costs off) select * from nv_parent where d between '2011-08-01'::date and '2011-08-31'::date;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Seq Scan on nv_parent
         Filter: ((d >= '2011-08-01'::date) AND (d <= '2011-08-31'::date))
   ->  Seq Scan on nv_child_2010
         Filter: ((d >= '2011-08-01'::date) AND (d <= '2011-08-31'::date))
   ->  Seq Scan on nv_child_2011
         Filter: ((d >= '2011-08-01'::date) AND (d <= '2011-08-31'::date))
(7 rows)

explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Seq Scan on nv_parent
         Filter: ((d >= '2009-08-01'::date) AND (d <= '2009-08-31'::date))
   ->  Seq Scan on nv_child_2010
         Filter: ((d >= '2009-08-01'::date) AND (d <= '2009-08-31'::date))
   ->  Seq Scan on nv_child_2011
         Filter: ((d >= '2009-08-01'::date) AND (d <= '2009-08-31'::date))
   ->  Seq Scan on nv_child_2009
         Filter: ((d >= '2009-08-01'::date) AND (d <= '2009-08-31'::date))
(9 rows)

-- after validation, the constraint should be used
alter table nv_child_2011 VALIDATE CONSTRAINT nv_child_2011_d_check;
ALTER TABLE
explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Append
   ->  Seq Scan on nv_parent
         Filter: ((d >= '2009-08-01'::date) AND (d <= '2009-08-31'::date))
   ->  Seq Scan on nv_child_2010
         Filter: ((d >= '2009-08-01'::date) AND (d <= '2009-08-31'::date))
   ->  Seq Scan on nv_child_2009
         Filter: ((d >= '2009-08-01'::date) AND (d <= '2009-08-31'::date))
(7 rows)

-- add an inherited NOT VALID constraint
alter table nv_parent add check (d between '2001-01-01'::date and '2099-12-31'::date) not valid;
ALTER TABLE
\d nv_child_2009
Table "public.nv_child_2009"
 Column | Type | Modifiers 
--------+------+-----------
 d      | date | 
Check constraints:
    "nv_child_2009_d_check" CHECK (d >= '2009-01-01'::date AND d <= '2009-12-31'::date)
    "nv_parent_d_check" CHECK (d >= '2001-01-01'::date AND d <= '2099-12-31'::date) NOT VALID
Inherits: nv_parent

-- we leave nv_parent and children around to help test pg_dump logic
-- Foreign key adding test with mixed types
-- Note: these tables are TEMP to avoid name conflicts when this test
-- is run in parallel with foreign_key.sql.
CREATE TEMP TABLE PKTABLE (ptest1 int PRIMARY KEY);
CREATE TABLE
INSERT INTO PKTABLE VALUES(42);
INSERT 0 1
CREATE TEMP TABLE FKTABLE (ftest1 inet);
CREATE TABLE
-- This next should fail, because int=inet does not exist
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ERROR:  42804: foreign key constraint "fktable_ftest1_fkey" cannot be implemented
DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
-- This should also fail for the same reason, but here we
-- give the column name
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable(ptest1);
ERROR:  42804: foreign key constraint "fktable_ftest1_fkey" cannot be implemented
DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
DROP TABLE FKTABLE;
DROP TABLE
-- This should succeed, even though they are different types,
-- because int=int8 exists and is a member of the integer opfamily
CREATE TEMP TABLE FKTABLE (ftest1 int8);
CREATE TABLE
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ALTER TABLE
-- Check it actually works
INSERT INTO FKTABLE VALUES(42);		-- should succeed
INSERT 0 1
INSERT INTO FKTABLE VALUES(43);		-- should fail
ERROR:  23503: insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
DROP TABLE FKTABLE;
DROP TABLE
-- This should fail, because we'd have to cast numeric to int which is
-- not an implicit coercion (or use numeric=numeric, but that's not part
-- of the integer opfamily)
CREATE TEMP TABLE FKTABLE (ftest1 numeric);
CREATE TABLE
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ERROR:  42804: foreign key constraint "fktable_ftest1_fkey" cannot be implemented
DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: numeric and integer.
DROP TABLE FKTABLE;
DROP TABLE
DROP TABLE PKTABLE;
DROP TABLE
-- On the other hand, this should work because int implicitly promotes to
-- numeric, and we allow promotion on the FK side
CREATE TEMP TABLE PKTABLE (ptest1 numeric PRIMARY KEY);
CREATE TABLE
INSERT INTO PKTABLE VALUES(42);
INSERT 0 1
CREATE TEMP TABLE FKTABLE (ftest1 int);
CREATE TABLE
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ALTER TABLE
-- Check it actually works
INSERT INTO FKTABLE VALUES(42);		-- should succeed
INSERT 0 1
INSERT INTO FKTABLE VALUES(43);		-- should fail
ERROR:  23503: insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
DROP TABLE FKTABLE;
DROP TABLE
DROP TABLE PKTABLE;
DROP TABLE
CREATE TEMP TABLE PKTABLE (ptest1 int, ptest2 inet,
                           PRIMARY KEY(ptest1, ptest2));
CREATE TABLE
-- This should fail, because we just chose really odd types
CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
CREATE TABLE
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) references pktable;
ERROR:  42804: foreign key constraint "fktable_ftest1_fkey" cannot be implemented
DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
DROP TABLE FKTABLE;
DROP TABLE
-- Again, so should this...
CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
CREATE TABLE
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
     references pktable(ptest1, ptest2);
ERROR:  42804: foreign key constraint "fktable_ftest1_fkey" cannot be implemented
DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
DROP TABLE FKTABLE;
DROP TABLE
-- This fails because we mixed up the column ordering
CREATE TEMP TABLE FKTABLE (ftest1 int, ftest2 inet);
CREATE TABLE
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
     references pktable(ptest2, ptest1);
ERROR:  42804: foreign key constraint "fktable_ftest1_fkey" cannot be implemented
DETAIL:  Key columns "ftest1" and "ptest2" are of incompatible types: integer and inet.
-- As does this...
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest2, ftest1)
     references pktable(ptest1, ptest2);
ERROR:  42804: foreign key constraint "fktable_ftest2_fkey" cannot be implemented
DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
DROP TABLE FKTABLE;
DROP TABLE
DROP TABLE PKTABLE;
DROP TABLE
-- Test that ALTER CONSTRAINT updates trigger deferrability properly
CREATE TEMP TABLE PKTABLE (ptest1 int primary key);
CREATE TABLE
CREATE TEMP TABLE FKTABLE (ftest1 int);
CREATE TABLE
ALTER TABLE FKTABLE ADD CONSTRAINT fknd FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ALTER TABLE
ALTER TABLE FKTABLE ADD CONSTRAINT fkdd FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE
ALTER TABLE FKTABLE ADD CONSTRAINT fkdi FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE
ALTER TABLE FKTABLE ADD CONSTRAINT fknd2 FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE
ALTER TABLE FKTABLE ALTER CONSTRAINT fknd2 NOT DEFERRABLE;
ALTER TABLE
ALTER TABLE FKTABLE ADD CONSTRAINT fkdd2 FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ALTER TABLE
ALTER TABLE FKTABLE ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE
ALTER TABLE FKTABLE ADD CONSTRAINT fkdi2 FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ALTER TABLE
ALTER TABLE FKTABLE ALTER CONSTRAINT fkdi2 DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE
SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
WHERE tgrelid = 'pktable'::regclass
ORDER BY 1,2,3;
 conname |         tgfoid         | tgtype | tgdeferrable | tginitdeferred 
---------+------------------------+--------+--------------+----------------
 fkdd    | "RI_FKey_cascade_del"  |      9 | f            | f
 fkdd    | "RI_FKey_noaction_upd" |     17 | t            | t
 fkdd2   | "RI_FKey_cascade_del"  |      9 | f            | f
 fkdd2   | "RI_FKey_noaction_upd" |     17 | t            | t
 fkdi    | "RI_FKey_cascade_del"  |      9 | f            | f
 fkdi    | "RI_FKey_noaction_upd" |     17 | t            | f
 fkdi2   | "RI_FKey_cascade_del"  |      9 | f            | f
 fkdi2   | "RI_FKey_noaction_upd" |     17 | t            | f
 fknd    | "RI_FKey_cascade_del"  |      9 | f            | f
 fknd    | "RI_FKey_noaction_upd" |     17 | f            | f
 fknd2   | "RI_FKey_cascade_del"  |      9 | f            | f
 fknd2   | "RI_FKey_noaction_upd" |     17 | f            | f
(12 rows)

SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
WHERE tgrelid = 'fktable'::regclass
ORDER BY 1,2,3;
 conname |       tgfoid        | tgtype | tgdeferrable | tginitdeferred 
---------+---------------------+--------+--------------+----------------
 fkdd    | "RI_FKey_check_ins" |      5 | t            | t
 fkdd    | "RI_FKey_check_upd" |     17 | t            | t
 fkdd2   | "RI_FKey_check_ins" |      5 | t            | t
 fkdd2   | "RI_FKey_check_upd" |     17 | t            | t
 fkdi    | "RI_FKey_check_ins" |      5 | t            | f
 fkdi    | "RI_FKey_check_upd" |     17 | t            | f
 fkdi2   | "RI_FKey_check_ins" |      5 | t            | f
 fkdi2   | "RI_FKey_check_upd" |     17 | t            | f
 fknd    | "RI_FKey_check_ins" |      5 | f            | f
 fknd    | "RI_FKey_check_upd" |     17 | f            | f
 fknd2   | "RI_FKey_check_ins" |      5 | f            | f
 fknd2   | "RI_FKey_check_upd" |     17 | f            | f
(12 rows)

-- temp tables should go away by themselves, need not drop them.
-- test check constraint adding
create table atacc1 ( test int );
CREATE TABLE
-- add a check constraint
alter table atacc1 add constraint atacc_test1 check (test>3);
ALTER TABLE
-- should fail
insert into atacc1 (test) values (2);
ERROR:  23514: new row for relation "atacc1" violates check constraint "atacc_test1"
DETAIL:  Failing row contains (2).
-- should succeed
insert into atacc1 (test) values (4);
INSERT 0 1
drop table atacc1;
DROP TABLE
-- let's do one where the check fails when added
create table atacc1 ( test int );
CREATE TABLE
-- insert a soon to be failing row
insert into atacc1 (test) values (2);
INSERT 0 1
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test>3);
ERROR:  23514: check constraint "atacc_test1" is violated by some row
insert into atacc1 (test) values (4);
INSERT 0 1
drop table atacc1;
DROP TABLE
-- let's do one where the check fails because the column doesn't exist
create table atacc1 ( test int );
CREATE TABLE
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test1>3);
ERROR:  42703: column "test1" does not exist
HINT:  Perhaps you meant to reference the column "atacc1.test".
drop table atacc1;
DROP TABLE
-- something a little more complicated
create table atacc1 ( test int, test2 int, test3 int);
CREATE TABLE
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test+test2<test3*4);
ALTER TABLE
-- should fail
insert into atacc1 (test,test2,test3) values (4,4,2);
ERROR:  23514: new row for relation "atacc1" violates check constraint "atacc_test1"
DETAIL:  Failing row contains (4, 4, 2).
-- should succeed
insert into atacc1 (test,test2,test3) values (4,4,5);
INSERT 0 1
drop table atacc1;
DROP TABLE
-- lets do some naming tests
create table atacc1 (test int check (test>3), test2 int);
CREATE TABLE
alter table atacc1 add check (test2>test);
ALTER TABLE
-- should fail for $2
insert into atacc1 (test2, test) values (3, 4);
ERROR:  23514: new row for relation "atacc1" violates check constraint "atacc1_check"
DETAIL:  Failing row contains (4, 3).
drop table atacc1;
DROP TABLE
-- inheritance related tests
create table atacc1 (test int);
CREATE TABLE
create table atacc2 (test2 int);
CREATE TABLE
create table atacc3 (test3 int) inherits (atacc1, atacc2);
CREATE TABLE
alter table atacc2 add constraint foo check (test2>0);
ALTER TABLE
-- fail and then succeed on atacc2
insert into atacc2 (test2) values (-3);
ERROR:  23514: new row for relation "atacc2" violates check constraint "foo"
DETAIL:  Failing row contains (-3).
insert into atacc2 (test2) values (3);
INSERT 0 1
-- fail and then succeed on atacc3
insert into atacc3 (test2) values (-3);
ERROR:  23514: new row for relation "atacc3" violates check constraint "foo"
DETAIL:  Failing row contains (null, -3, null).
insert into atacc3 (test2) values (3);
INSERT 0 1
drop table atacc3;
DROP TABLE
drop table atacc2;
DROP TABLE
drop table atacc1;
DROP TABLE
-- same things with one created with INHERIT
create table atacc1 (test int);
CREATE TABLE
create table atacc2 (test2 int);
CREATE TABLE
create table atacc3 (test3 int) inherits (atacc1, atacc2);
CREATE TABLE
alter table atacc3 no inherit atacc2;
ALTER TABLE
-- fail
alter table atacc3 no inherit atacc2;
ERROR:  42P01: relation "atacc2" is not a parent of relation "atacc3"
-- make sure it really isn't a child
insert into atacc3 (test2) values (3);
INSERT 0 1
select test2 from atacc2;
 test2 
-------
(0 rows)

-- fail due to missing constraint
alter table atacc2 add constraint foo check (test2>0);
ALTER TABLE
alter table atacc3 inherit atacc2;
ERROR:  42804: child table is missing constraint "foo"
-- fail due to missing column
alter table atacc3 rename test2 to testx;
ALTER TABLE
alter table atacc3 inherit atacc2;
ERROR:  42804: child table is missing column "test2"
-- fail due to mismatched data type
alter table atacc3 add test2 bool;
ALTER TABLE
alter table atacc3 inherit atacc2;
ERROR:  42804: child table "atacc3" has different type for column "test2"
alter table atacc3 drop test2;
ALTER TABLE
-- succeed
alter table atacc3 add test2 int;
ALTER TABLE
update atacc3 set test2 = 4 where test2 is null;
UPDATE 1
alter table atacc3 add constraint foo check (test2>0);
ALTER TABLE
alter table atacc3 inherit atacc2;
ALTER TABLE
-- fail due to duplicates and circular inheritance
alter table atacc3 inherit atacc2;
ERROR:  42P07: relation "atacc2" would be inherited from more than once
alter table atacc2 inherit atacc3;
ERROR:  42P07: circular inheritance not allowed
DETAIL:  "atacc3" is already a child of "atacc2".
alter table atacc2 inherit atacc2;
ERROR:  42P07: circular inheritance not allowed
DETAIL:  "atacc2" is already a child of "atacc2".
-- test that we really are a child now (should see 4 not 3 and cascade should go through)
select test2 from atacc2;
 test2 
-------
     4
(1 row)

drop table atacc2 cascade;
NOTICE:  00000: drop cascades to table atacc3
DROP TABLE
drop table atacc1;
DROP TABLE
-- adding only to a parent is allowed as of 9.2
create table atacc1 (test int);
CREATE TABLE
create table atacc2 (test2 int) inherits (atacc1);
CREATE TABLE
-- ok:
alter table atacc1 add constraint foo check (test>0) no inherit;
ALTER TABLE
-- check constraint is not there on child
insert into atacc2 (test) values (-3);
INSERT 0 1
-- check constraint is there on parent
insert into atacc1 (test) values (-3);
ERROR:  23514: new row for relation "atacc1" violates check constraint "foo"
DETAIL:  Failing row contains (-3).
insert into atacc1 (test) values (3);
INSERT 0 1
-- fail, violating row:
alter table atacc2 add constraint foo check (test>0) no inherit;
ERROR:  23514: check constraint "foo" is violated by some row
drop table atacc2;
DROP TABLE
drop table atacc1;
DROP TABLE
-- test unique constraint adding
create table atacc1 ( test int ) with oids;
CREATE TABLE
-- add a unique constraint
alter table atacc1 add constraint atacc_test1 unique (test);
ALTER TABLE
-- insert first value
insert into atacc1 (test) values (2);
INSERT 35703 1
-- should fail
insert into atacc1 (test) values (2);
ERROR:  23505: duplicate key value violates unique constraint "atacc_test1"
DETAIL:  Key (test)=(2) already exists.
-- should succeed
insert into atacc1 (test) values (4);
INSERT 35705 1
-- try adding a unique oid constraint
alter table atacc1 add constraint atacc_oid1 unique(oid);
ALTER TABLE
-- try to create duplicates via alter table using - should fail
alter table atacc1 alter column test type integer using 0;
ERROR:  23505: could not create unique index "atacc_test1"
DETAIL:  Key (test)=(0) is duplicated.
drop table atacc1;
DROP TABLE
-- let's do one where the unique constraint fails when added
create table atacc1 ( test int );
CREATE TABLE
-- insert soon to be failing rows
insert into atacc1 (test) values (2);
INSERT 0 1
insert into atacc1 (test) values (2);
INSERT 0 1
-- add a unique constraint (fails)
alter table atacc1 add constraint atacc_test1 unique (test);
ERROR:  23505: could not create unique index "atacc_test1"
DETAIL:  Key (test)=(2) is duplicated.
insert into atacc1 (test) values (3);
INSERT 0 1
drop table atacc1;
DROP TABLE
-- let's do one where the unique constraint fails
-- because the column doesn't exist
create table atacc1 ( test int );
CREATE TABLE
-- add a unique constraint (fails)
alter table atacc1 add constraint atacc_test1 unique (test1);
ERROR:  42703: column "test1" named in key does not exist
drop table atacc1;
DROP TABLE
-- something a little more complicated
create table atacc1 ( test int, test2 int);
CREATE TABLE
-- add a unique constraint
alter table atacc1 add constraint atacc_test1 unique (test, test2);
ALTER TABLE
-- insert initial value
insert into atacc1 (test,test2) values (4,4);
INSERT 0 1
-- should fail
insert into atacc1 (test,test2) values (4,4);
ERROR:  23505: duplicate key value violates unique constraint "atacc_test1"
DETAIL:  Key (test, test2)=(4, 4) already exists.
-- should all succeed
insert into atacc1 (test,test2) values (4,5);
INSERT 0 1
insert into atacc1 (test,test2) values (5,4);
INSERT 0 1
insert into atacc1 (test,test2) values (5,5);
INSERT 0 1
drop table atacc1;
DROP TABLE
-- lets do some naming tests
create table atacc1 (test int, test2 int, unique(test));
CREATE TABLE
alter table atacc1 add unique (test2);
ALTER TABLE
-- should fail for @@ second one @@
insert into atacc1 (test2, test) values (3, 3);
INSERT 0 1
insert into atacc1 (test2, test) values (2, 3);
ERROR:  23505: duplicate key value violates unique constraint "atacc1_test_key"
DETAIL:  Key (test)=(3) already exists.
drop table atacc1;
DROP TABLE
-- test primary key constraint adding
create table atacc1 ( test int ) with oids;
CREATE TABLE
-- add a primary key constraint
alter table atacc1 add constraint atacc_test1 primary key (test);
ALTER TABLE
-- insert first value
insert into atacc1 (test) values (2);
INSERT 35740 1
-- should fail
insert into atacc1 (test) values (2);
ERROR:  23505: duplicate key value violates unique constraint "atacc_test1"
DETAIL:  Key (test)=(2) already exists.
-- should succeed
insert into atacc1 (test) values (4);
INSERT 35742 1
-- inserting NULL should fail
insert into atacc1 (test) values(NULL);
ERROR:  23502: null value in column "test" violates not-null constraint
DETAIL:  Failing row contains (null).
-- try adding a second primary key (should fail)
alter table atacc1 add constraint atacc_oid1 primary key(oid);
ERROR:  42P16: multiple primary keys for table "atacc1" are not allowed
-- drop first primary key constraint
alter table atacc1 drop constraint atacc_test1 restrict;
ALTER TABLE
-- try adding a primary key on oid (should succeed)
alter table atacc1 add constraint atacc_oid1 primary key(oid);
ALTER TABLE
drop table atacc1;
DROP TABLE
-- let's do one where the primary key constraint fails when added
create table atacc1 ( test int );
CREATE TABLE
-- insert soon to be failing rows
insert into atacc1 (test) values (2);
INSERT 0 1
insert into atacc1 (test) values (2);
INSERT 0 1
-- add a primary key (fails)
alter table atacc1 add constraint atacc_test1 primary key (test);
ERROR:  23505: could not create unique index "atacc_test1"
DETAIL:  Key (test)=(2) is duplicated.
insert into atacc1 (test) values (3);
INSERT 0 1
drop table atacc1;
DROP TABLE
-- let's do another one where the primary key constraint fails when added
create table atacc1 ( test int );
CREATE TABLE
-- insert soon to be failing row
insert into atacc1 (test) values (NULL);
INSERT 0 1
-- add a primary key (fails)
alter table atacc1 add constraint atacc_test1 primary key (test);
ERROR:  23502: column "test" contains null values
insert into atacc1 (test) values (3);
INSERT 0 1
drop table atacc1;
DROP TABLE
-- let's do one where the primary key constraint fails
-- because the column doesn't exist
create table atacc1 ( test int );
CREATE TABLE
-- add a primary key constraint (fails)
alter table atacc1 add constraint atacc_test1 primary key (test1);
ERROR:  42703: column "test1" named in key does not exist
drop table atacc1;
DROP TABLE
-- adding a new column as primary key to a non-empty table.
-- should fail unless the column has a non-null default value.
create table atacc1 ( test int );
CREATE TABLE
insert into atacc1 (test) values (0);
INSERT 0 1
-- add a primary key column without a default (fails).
alter table atacc1 add column test2 int primary key;
ERROR:  23502: column "test2" contains null values
-- now add a primary key column with a default (succeeds).
alter table atacc1 add column test2 int default 0 primary key;
ALTER TABLE
drop table atacc1;
DROP TABLE
-- something a little more complicated
create table atacc1 ( test int, test2 int);
CREATE TABLE
-- add a primary key constraint
alter table atacc1 add constraint atacc_test1 primary key (test, test2);
ALTER TABLE
-- try adding a second primary key - should fail
alter table atacc1 add constraint atacc_test2 primary key (test);
ERROR:  42P16: multiple primary keys for table "atacc1" are not allowed
-- insert initial value
insert into atacc1 (test,test2) values (4,4);
INSERT 0 1
-- should fail
insert into atacc1 (test,test2) values (4,4);
ERROR:  23505: duplicate key value violates unique constraint "atacc_test1"
DETAIL:  Key (test, test2)=(4, 4) already exists.
insert into atacc1 (test,test2) values (NULL,3);
ERROR:  23502: null value in column "test" violates not-null constraint
DETAIL:  Failing row contains (null, 3).
insert into atacc1 (test,test2) values (3, NULL);
ERROR:  23502: null value in column "test2" violates not-null constraint
DETAIL:  Failing row contains (3, null).
insert into atacc1 (test,test2) values (NULL,NULL);
ERROR:  23502: null value in column "test" violates not-null constraint
DETAIL:  Failing row contains (null, null).
-- should all succeed
insert into atacc1 (test,test2) values (4,5);
INSERT 0 1
insert into atacc1 (test,test2) values (5,4);
INSERT 0 1
insert into atacc1 (test,test2) values (5,5);
INSERT 0 1
drop table atacc1;
DROP TABLE
-- lets do some naming tests
create table atacc1 (test int, test2 int, primary key(test));
CREATE TABLE
-- only first should succeed
insert into atacc1 (test2, test) values (3, 3);
INSERT 0 1
insert into atacc1 (test2, test) values (2, 3);
ERROR:  23505: duplicate key value violates unique constraint "atacc1_pkey"
DETAIL:  Key (test)=(3) already exists.
insert into atacc1 (test2, test) values (1, NULL);
ERROR:  23502: null value in column "test" violates not-null constraint
DETAIL:  Failing row contains (null, 1).
drop table atacc1;
DROP TABLE
-- alter table / alter column [set/drop] not null tests
-- try altering system catalogs, should fail
alter table pg_class alter column relname drop not null;
ERROR:  42501: permission denied: "pg_class" is a system catalog
alter table pg_class alter relname set not null;
ERROR:  42501: permission denied: "pg_class" is a system catalog
-- try altering non-existent table, should fail
alter table non_existent alter column bar set not null;
ERROR:  42P01: relation "non_existent" does not exist
alter table non_existent alter column bar drop not null;
ERROR:  42P01: relation "non_existent" does not exist
-- test setting columns to null and not null and vice versa
-- test checking for null values and primary key
create table atacc1 (test int not null) with oids;
CREATE TABLE
alter table atacc1 add constraint "atacc1_pkey" primary key (test);
ALTER TABLE
alter table atacc1 alter column test drop not null;
ERROR:  42P16: column "test" is in a primary key
alter table atacc1 drop constraint "atacc1_pkey";
ALTER TABLE
alter table atacc1 alter column test drop not null;
ALTER TABLE
insert into atacc1 values (null);
INSERT 35783 1
alter table atacc1 alter test set not null;
ERROR:  23502: column "test" contains null values
delete from atacc1;
DELETE 1
alter table atacc1 alter test set not null;
ALTER TABLE
-- try altering a non-existent column, should fail
alter table atacc1 alter bar set not null;
ERROR:  42703: column "bar" of relation "atacc1" does not exist
alter table atacc1 alter bar drop not null;
ERROR:  42703: column "bar" of relation "atacc1" does not exist
-- try altering the oid column, should fail
alter table atacc1 alter oid set not null;
ERROR:  0A000: cannot alter system column "oid"
alter table atacc1 alter oid drop not null;
ERROR:  0A000: cannot alter system column "oid"
-- try creating a view and altering that, should fail
create view myview as select * from atacc1;
CREATE VIEW
alter table myview alter column test drop not null;
ERROR:  42809: "myview" is not a table or foreign table
alter table myview alter column test set not null;
ERROR:  42809: "myview" is not a table or foreign table
drop view myview;
DROP VIEW
drop table atacc1;
DROP TABLE
-- test inheritance
create table parent (a int);
CREATE TABLE
create table child (b varchar(255)) inherits (parent);
CREATE TABLE
alter table parent alter a set not null;
ALTER TABLE
insert into parent values (NULL);
ERROR:  23502: null value in column "a" violates not-null constraint
DETAIL:  Failing row contains (null).
insert into child (a, b) values (NULL, 'foo');
ERROR:  23502: null value in column "a" violates not-null constraint
DETAIL:  Failing row contains (null, foo).
alter table parent alter a drop not null;
ALTER TABLE
insert into parent values (NULL);
INSERT 0 1
insert into child (a, b) values (NULL, 'foo');
INSERT 0 1
alter table only parent alter a set not null;
ERROR:  23502: column "a" contains null values
alter table child alter a set not null;
ERROR:  23502: column "a" contains null values
delete from parent;
DELETE 2
alter table only parent alter a set not null;
ALTER TABLE
insert into parent values (NULL);
ERROR:  23502: null value in column "a" violates not-null constraint
DETAIL:  Failing row contains (null).
alter table child alter a set not null;
ALTER TABLE
insert into child (a, b) values (NULL, 'foo');
ERROR:  23502: null value in column "a" violates not-null constraint
DETAIL:  Failing row contains (null, foo).
delete from child;
DELETE 0
alter table child alter a set not null;
ALTER TABLE
insert into child (a, b) values (NULL, 'foo');
ERROR:  23502: null value in column "a" violates not-null constraint
DETAIL:  Failing row contains (null, foo).
drop table child;
DROP TABLE
drop table parent;
DROP TABLE
-- test setting and removing default values
create table def_test (
	c1	int4 default 5,
	c2	text default 'initial_default'
);
CREATE TABLE
insert into def_test default values;
INSERT 0 1
alter table def_test alter column c1 drop default;
ALTER TABLE
insert into def_test default values;
INSERT 0 1
alter table def_test alter column c2 drop default;
ALTER TABLE
insert into def_test default values;
INSERT 0 1
alter table def_test alter column c1 set default 10;
ALTER TABLE
alter table def_test alter column c2 set default 'new_default';
ALTER TABLE
insert into def_test default values;
INSERT 0 1
select * from def_test;
 c1 |       c2        
----+-----------------
  5 | initial_default
    | initial_default
    | 
 10 | new_default
(4 rows)

-- set defaults to an incorrect type: this should fail
alter table def_test alter column c1 set default 'wrong_datatype';
ERROR:  22P02: invalid input syntax for integer: "wrong_datatype"
alter table def_test alter column c2 set default 20;
ALTER TABLE
-- set defaults on a non-existent column: this should fail
alter table def_test alter column c3 set default 30;
ERROR:  42703: column "c3" of relation "def_test" does not exist
-- set defaults on views: we need to create a view, add a rule
-- to allow insertions into it, and then alter the view to add
-- a default
create view def_view_test as select * from def_test;
CREATE VIEW
create rule def_view_test_ins as
	on insert to def_view_test
	do instead insert into def_test select new.*;
CREATE RULE
insert into def_view_test default values;
INSERT 0 1
alter table def_view_test alter column c1 set default 45;
ALTER TABLE
insert into def_view_test default values;
INSERT 0 1
alter table def_view_test alter column c2 set default 'view_default';
ALTER TABLE
insert into def_view_test default values;
INSERT 0 1
select * from def_view_test;
 c1 |       c2        
----+-----------------
  5 | initial_default
    | initial_default
    | 
 10 | new_default
    | 
 45 | 
 45 | view_default
(7 rows)

drop rule def_view_test_ins on def_view_test;
DROP RULE
drop view def_view_test;
DROP VIEW
drop table def_test;
DROP TABLE
-- alter table / drop column tests
-- try altering system catalogs, should fail
alter table pg_class drop column relname;
ERROR:  42501: permission denied: "pg_class" is a system catalog
-- try altering non-existent table, should fail
alter table nosuchtable drop column bar;
ERROR:  42P01: relation "nosuchtable" does not exist
-- test dropping columns
create table atacc1 (a int4 not null, b int4, c int4 not null, d int4) with oids;
CREATE TABLE
insert into atacc1 values (1, 2, 3, 4);
INSERT 35815 1
alter table atacc1 drop a;
ALTER TABLE
alter table atacc1 drop a;
ERROR:  42703: column "a" of relation "atacc1" does not exist
-- SELECTs
select * from atacc1;
 b | c | d 
---+---+---
 2 | 3 | 4
(1 row)

select * from atacc1 order by a;
ERROR:  42703: column "a" does not exist
LINE 1: select * from atacc1 order by a;
                                      ^
select * from atacc1 order by "........pg.dropped.1........";
ERROR:  42703: column "........pg.dropped.1........" does not exist
LINE 1: select * from atacc1 order by "........pg.dropped.1........"...
                                      ^
select * from atacc1 group by a;
ERROR:  42703: column "a" does not exist
LINE 1: select * from atacc1 group by a;
                                      ^
select * from atacc1 group by "........pg.dropped.1........";
ERROR:  42703: column "........pg.dropped.1........" does not exist
LINE 1: select * from atacc1 group by "........pg.dropped.1........"...
                                      ^
select atacc1.* from atacc1;
 b | c | d 
---+---+---
 2 | 3 | 4
(1 row)

select a from atacc1;
ERROR:  42703: column "a" does not exist
LINE 1: select a from atacc1;
               ^
select atacc1.a from atacc1;
ERROR:  42703: column atacc1.a does not exist
LINE 1: select atacc1.a from atacc1;
               ^
select b,c,d from atacc1;
 b | c | d 
---+---+---
 2 | 3 | 4
(1 row)

select a,b,c,d from atacc1;
ERROR:  42703: column "a" does not exist
LINE 1: select a,b,c,d from atacc1;
               ^
select * from atacc1 where a = 1;
ERROR:  42703: column "a" does not exist
LINE 1: select * from atacc1 where a = 1;
                                   ^
select "........pg.dropped.1........" from atacc1;
ERROR:  42703: column "........pg.dropped.1........" does not exist
LINE 1: select "........pg.dropped.1........" from atacc1;
               ^
select atacc1."........pg.dropped.1........" from atacc1;
ERROR:  42703: column atacc1.........pg.dropped.1........ does not exist
LINE 1: select atacc1."........pg.dropped.1........" from atacc1;
               ^
select "........pg.dropped.1........",b,c,d from atacc1;
ERROR:  42703: column "........pg.dropped.1........" does not exist
LINE 1: select "........pg.dropped.1........",b,c,d from atacc1;
               ^
select * from atacc1 where "........pg.dropped.1........" = 1;
ERROR:  42703: column "........pg.dropped.1........" does not exist
LINE 1: select * from atacc1 where "........pg.dropped.1........" = ...
                                   ^
-- UPDATEs
update atacc1 set a = 3;
ERROR:  42703: column "a" of relation "atacc1" does not exist
LINE 1: update atacc1 set a = 3;
                          ^
update atacc1 set b = 2 where a = 3;
ERROR:  42703: column "a" does not exist
LINE 1: update atacc1 set b = 2 where a = 3;
                                      ^
update atacc1 set "........pg.dropped.1........" = 3;
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: update atacc1 set "........pg.dropped.1........" = 3;
                          ^
update atacc1 set b = 2 where "........pg.dropped.1........" = 3;
ERROR:  42703: column "........pg.dropped.1........" does not exist
LINE 1: update atacc1 set b = 2 where "........pg.dropped.1........"...
                                      ^
-- INSERTs
insert into atacc1 values (10, 11, 12, 13);
ERROR:  42601: INSERT has more expressions than target columns
LINE 1: insert into atacc1 values (10, 11, 12, 13);
                                               ^
insert into atacc1 values (default, 11, 12, 13);
ERROR:  42601: INSERT has more expressions than target columns
LINE 1: insert into atacc1 values (default, 11, 12, 13);
                                                    ^
insert into atacc1 values (11, 12, 13);
INSERT 35816 1
insert into atacc1 (a) values (10);
ERROR:  42703: column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a) values (10);
                            ^
insert into atacc1 (a) values (default);
ERROR:  42703: column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a) values (default);
                            ^
insert into atacc1 (a,b,c,d) values (10,11,12,13);
ERROR:  42703: column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a,b,c,d) values (10,11,12,13);
                            ^
insert into atacc1 (a,b,c,d) values (default,11,12,13);
ERROR:  42703: column "a" of relation "atacc1" does not exist
LINE 1: insert into atacc1 (a,b,c,d) values (default,11,12,13);
                            ^
insert into atacc1 (b,c,d) values (11,12,13);
INSERT 35817 1
insert into atacc1 ("........pg.dropped.1........") values (10);
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
                            ^
insert into atacc1 ("........pg.dropped.1........") values (default);
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
                            ^
insert into atacc1 ("........pg.dropped.1........",b,c,d) values (10,11,12,13);
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
                            ^
insert into atacc1 ("........pg.dropped.1........",b,c,d) values (default,11,12,13);
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
                            ^
-- DELETEs
delete from atacc1 where a = 3;
ERROR:  42703: column "a" does not exist
LINE 1: delete from atacc1 where a = 3;
                                 ^
delete from atacc1 where "........pg.dropped.1........" = 3;
ERROR:  42703: column "........pg.dropped.1........" does not exist
LINE 1: delete from atacc1 where "........pg.dropped.1........" = 3;
                                 ^
delete from atacc1;
DELETE 3
-- try dropping a non-existent column, should fail
alter table atacc1 drop bar;
ERROR:  42703: column "bar" of relation "atacc1" does not exist
-- try dropping the oid column, should succeed
alter table atacc1 drop oid;
ALTER TABLE
-- try dropping the xmin column, should fail
alter table atacc1 drop xmin;
ERROR:  0A000: cannot drop system column "xmin"
-- try creating a view and altering that, should fail
create view myview as select * from atacc1;
CREATE VIEW
select * from myview;
 b | c | d 
---+---+---
(0 rows)

alter table myview drop d;
ERROR:  42809: "myview" is not a table, composite type, or foreign table
drop view myview;
DROP VIEW
-- test some commands to make sure they fail on the dropped column
analyze atacc1(a);
ERROR:  42703: column "a" of relation "atacc1" does not exist
analyze atacc1("........pg.dropped.1........");
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
vacuum analyze atacc1(a);
ERROR:  42703: column "a" of relation "atacc1" does not exist
vacuum analyze atacc1("........pg.dropped.1........");
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
comment on column atacc1.a is 'testing';
ERROR:  42703: column "a" of relation "atacc1" does not exist
comment on column atacc1."........pg.dropped.1........" is 'testing';
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
alter table atacc1 alter a set storage plain;
ERROR:  42703: column "a" of relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" set storage plain;
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
alter table atacc1 alter a set statistics 0;
ERROR:  42703: column "a" of relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" set statistics 0;
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
alter table atacc1 alter a set default 3;
ERROR:  42703: column "a" of relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" set default 3;
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
alter table atacc1 alter a drop default;
ERROR:  42703: column "a" of relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" drop default;
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
alter table atacc1 alter a set not null;
ERROR:  42703: column "a" of relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" set not null;
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
alter table atacc1 alter a drop not null;
ERROR:  42703: column "a" of relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" drop not null;
ERROR:  42703: column "........pg.dropped.1........" of relation "atacc1" does not exist
alter table atacc1 rename a to x;
ERROR:  42703: column "a" does not exist
alter table atacc1 rename "........pg.dropped.1........" to x;
ERROR:  42703: column "........pg.dropped.1........" does not exist
alter table atacc1 add primary key(a);
ERROR:  42703: column "a" named in key does not exist
alter table atacc1 add primary key("........pg.dropped.1........");
ERROR:  42703: column "........pg.dropped.1........" named in key does not exist
alter table atacc1 add unique(a);
ERROR:  42703: column "a" named in key does not exist
alter table atacc1 add unique("........pg.dropped.1........");
ERROR:  42703: column "........pg.dropped.1........" named in key does not exist
alter table atacc1 add check (a > 3);
ERROR:  42703: column "a" does not exist
alter table atacc1 add check ("........pg.dropped.1........" > 3);
ERROR:  42703: column "........pg.dropped.1........" does not exist
create table atacc2 (id int4 unique);
CREATE TABLE
alter table atacc1 add foreign key (a) references atacc2(id);
ERROR:  42703: column "a" referenced in foreign key constraint does not exist
alter table atacc1 add foreign key ("........pg.dropped.1........") references atacc2(id);
ERROR:  42703: column "........pg.dropped.1........" referenced in foreign key constraint does not exist
alter table atacc2 add foreign key (id) references atacc1(a);
ERROR:  42703: column "a" referenced in foreign key constraint does not exist
alter table atacc2 add foreign key (id) references atacc1("........pg.dropped.1........");
ERROR:  42703: column "........pg.dropped.1........" referenced in foreign key constraint does not exist
drop table atacc2;
DROP TABLE
create index "testing_idx" on atacc1(a);
ERROR:  42703: column "a" does not exist
create index "testing_idx" on atacc1("........pg.dropped.1........");
ERROR:  42703: column "........pg.dropped.1........" does not exist
-- test create as and select into
insert into atacc1 values (21, 22, 23);
INSERT 0 1
create table test1 as select * from atacc1;
SELECT 1
select * from test1;
 b  | c  | d  
----+----+----
 21 | 22 | 23
(1 row)

drop table test1;
DROP TABLE
select * into test2 from atacc1;
SELECT 1
select * from test2;
 b  | c  | d  
----+----+----
 21 | 22 | 23
(1 row)

drop table test2;
DROP TABLE
-- try dropping all columns
alter table atacc1 drop c;
ALTER TABLE
alter table atacc1 drop d;
ALTER TABLE
alter table atacc1 drop b;
ALTER TABLE
select * from atacc1;
--
(1 row)

drop table atacc1;
DROP TABLE
-- test constraint error reporting in presence of dropped columns
create table atacc1 (id serial primary key, value int check (value < 10));
CREATE TABLE
insert into atacc1(value) values (100);
ERROR:  23514: new row for relation "atacc1" violates check constraint "atacc1_value_check"
DETAIL:  Failing row contains (1, 100).
alter table atacc1 drop column value;
ALTER TABLE
alter table atacc1 add column value int check (value < 10);
ALTER TABLE
insert into atacc1(value) values (100);
ERROR:  23514: new row for relation "atacc1" violates check constraint "atacc1_value_check"
DETAIL:  Failing row contains (2, 100).
insert into atacc1(id, value) values (null, 0);
ERROR:  23502: null value in column "id" violates not-null constraint
DETAIL:  Failing row contains (null, 0).
drop table atacc1;
DROP TABLE
-- test inheritance
create table parent (a int, b int, c int);
CREATE TABLE
insert into parent values (1, 2, 3);
INSERT 0 1
alter table parent drop a;
ALTER TABLE
create table child (d varchar(255)) inherits (parent);
CREATE TABLE
insert into child values (12, 13, 'testing');
INSERT 0 1
select * from parent;
 b  | c  
----+----
  2 |  3
 12 | 13
(2 rows)

select * from child;
 b  | c  |    d    
----+----+---------
 12 | 13 | testing
(1 row)

alter table parent drop c;
ALTER TABLE
select * from parent;
 b  
----
  2
 12
(2 rows)

select * from child;
 b  |    d    
----+---------
 12 | testing
(1 row)

drop table child;
DROP TABLE
drop table parent;
DROP TABLE
-- test copy in/out
create table test (a int4, b int4, c int4);
CREATE TABLE
insert into test values (1,2,3);
INSERT 0 1
alter table test drop a;
ALTER TABLE
copy test to stdout;
2	3
copy test(a) to stdout;
ERROR:  42703: column "a" of relation "test" does not exist
copy test("........pg.dropped.1........") to stdout;
ERROR:  42703: column "........pg.dropped.1........" of relation "test" does not exist
copy test from stdin;
ERROR:  22P04: extra data after last expected column
CONTEXT:  COPY test, line 1: "10	11	12"
select * from test;
 b | c 
---+---
 2 | 3
(1 row)

copy test from stdin;
COPY 1
select * from test;
 b  | c  
----+----
  2 |  3
 21 | 22
(2 rows)

copy test(a) from stdin;
ERROR:  42703: column "a" of relation "test" does not exist
copy test("........pg.dropped.1........") from stdin;
ERROR:  42703: column "........pg.dropped.1........" of relation "test" does not exist
copy test(b,c) from stdin;
COPY 1
select * from test;
 b  | c  
----+----
  2 |  3
 21 | 22
 31 | 32
(3 rows)

drop table test;
DROP TABLE
-- test inheritance
create table dropColumn (a int, b int, e int);
CREATE TABLE
create table dropColumnChild (c int) inherits (dropColumn);
CREATE TABLE
create table dropColumnAnother (d int) inherits (dropColumnChild);
CREATE TABLE
-- these two should fail
alter table dropColumnchild drop column a;
ERROR:  42P16: cannot drop inherited column "a"
alter table only dropColumnChild drop column b;
ERROR:  42P16: cannot drop inherited column "b"
-- these three should work
alter table only dropColumn drop column e;
ALTER TABLE
alter table dropColumnChild drop column c;
ALTER TABLE
alter table dropColumn drop column a;
ALTER TABLE
create table renameColumn (a int);
CREATE TABLE
create table renameColumnChild (b int) inherits (renameColumn);
CREATE TABLE
create table renameColumnAnother (c int) inherits (renameColumnChild);
CREATE TABLE
-- these three should fail
alter table renameColumnChild rename column a to d;
ERROR:  42P16: cannot rename inherited column "a"
alter table only renameColumnChild rename column a to d;
ERROR:  42P16: inherited column "a" must be renamed in child tables too
alter table only renameColumn rename column a to d;
ERROR:  42P16: inherited column "a" must be renamed in child tables too
-- these should work
alter table renameColumn rename column a to d;
ALTER TABLE
alter table renameColumnChild rename column b to a;
ALTER TABLE
-- these should work
alter table if exists doesnt_exist_tab rename column a to d;
NOTICE:  00000: relation "doesnt_exist_tab" does not exist, skipping
ALTER TABLE
alter table if exists doesnt_exist_tab rename column b to a;
NOTICE:  00000: relation "doesnt_exist_tab" does not exist, skipping
ALTER TABLE
-- this should work
alter table renameColumn add column w int;
ALTER TABLE
-- this should fail
alter table only renameColumn add column x int;
ERROR:  42P16: column must be added to child tables too
-- Test corner cases in dropping of inherited columns
create table p1 (f1 int, f2 int);
CREATE TABLE
create table c1 (f1 int not null) inherits(p1);
NOTICE:  00000: merging column "f1" with inherited definition
CREATE TABLE
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  42P16: cannot drop inherited column "f1"
-- should work
alter table p1 drop column f1;
ALTER TABLE
-- c1.f1 is still there, but no longer inherited
select f1 from c1;
 f1 
----
(0 rows)

alter table c1 drop column f1;
ALTER TABLE
select f1 from c1;
ERROR:  42703: column "f1" does not exist
LINE 1: select f1 from c1;
               ^
HINT:  Perhaps you meant to reference the column "c1.f2".
drop table p1 cascade;
NOTICE:  00000: drop cascades to table c1
DROP TABLE
create table p1 (f1 int, f2 int);
CREATE TABLE
create table c1 () inherits(p1);
CREATE TABLE
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  42P16: cannot drop inherited column "f1"
alter table p1 drop column f1;
ALTER TABLE
-- c1.f1 is dropped now, since there is no local definition for it
select f1 from c1;
ERROR:  42703: column "f1" does not exist
LINE 1: select f1 from c1;
               ^
HINT:  Perhaps you meant to reference the column "c1.f2".
drop table p1 cascade;
NOTICE:  00000: drop cascades to table c1
DROP TABLE
create table p1 (f1 int, f2 int);
CREATE TABLE
create table c1 () inherits(p1);
CREATE TABLE
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  42P16: cannot drop inherited column "f1"
alter table only p1 drop column f1;
ALTER TABLE
-- c1.f1 is NOT dropped, but must now be considered non-inherited
alter table c1 drop column f1;
ALTER TABLE
drop table p1 cascade;
NOTICE:  00000: drop cascades to table c1
DROP TABLE
create table p1 (f1 int, f2 int);
CREATE TABLE
create table c1 (f1 int not null) inherits(p1);
NOTICE:  00000: merging column "f1" with inherited definition
CREATE TABLE
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  42P16: cannot drop inherited column "f1"
alter table only p1 drop column f1;
ALTER TABLE
-- c1.f1 is still there, but no longer inherited
alter table c1 drop column f1;
ALTER TABLE
drop table p1 cascade;
NOTICE:  00000: drop cascades to table c1
DROP TABLE
create table p1(id int, name text);
CREATE TABLE
create table p2(id2 int, name text, height int);
CREATE TABLE
create table c1(age int) inherits(p1,p2);
NOTICE:  00000: merging multiple inherited definitions of column "name"
CREATE TABLE
create table gc1() inherits (c1);
CREATE TABLE
select relname, attname, attinhcount, attislocal
from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
order by relname, attnum;
 relname | attname | attinhcount | attislocal 
---------+---------+-------------+------------
 c1      | id      |           1 | f
 c1      | name    |           2 | f
 c1      | id2     |           1 | f
 c1      | height  |           1 | f
 c1      | age     |           0 | t
 gc1     | id      |           1 | f
 gc1     | name    |           1 | f
 gc1     | id2     |           1 | f
 gc1     | height  |           1 | f
 gc1     | age     |           1 | f
 p1      | id      |           0 | t
 p1      | name    |           0 | t
 p2      | id2     |           0 | t
 p2      | name    |           0 | t
 p2      | height  |           0 | t
(15 rows)

-- should work
alter table only p1 drop column name;
ALTER TABLE
-- should work. Now c1.name is local and inhcount is 0.
alter table p2 drop column name;
ALTER TABLE
-- should be rejected since its inherited
alter table gc1 drop column name;
ERROR:  42P16: cannot drop inherited column "name"
-- should work, and drop gc1.name along
alter table c1 drop column name;
ALTER TABLE
-- should fail: column does not exist
alter table gc1 drop column name;
ERROR:  42703: column "name" of relation "gc1" does not exist
-- should work and drop the attribute in all tables
alter table p2 drop column height;
ALTER TABLE
-- IF EXISTS test
create table dropColumnExists ();
CREATE TABLE
alter table dropColumnExists drop column non_existing; --fail
ERROR:  42703: column "non_existing" of relation "dropcolumnexists" does not exist
alter table dropColumnExists drop column if exists non_existing; --succeed
NOTICE:  00000: column "non_existing" of relation "dropcolumnexists" does not exist, skipping
ALTER TABLE
select relname, attname, attinhcount, attislocal
from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
order by relname, attnum;
 relname | attname | attinhcount | attislocal 
---------+---------+-------------+------------
 c1      | id      |           1 | f
 c1      | id2     |           1 | f
 c1      | age     |           0 | t
 gc1     | id      |           1 | f
 gc1     | id2     |           1 | f
 gc1     | age     |           1 | f
 p1      | id      |           0 | t
 p2      | id2     |           0 | t
(8 rows)

drop table p1, p2 cascade;
NOTICE:  00000: drop cascades to 2 other objects
DETAIL:  drop cascades to table c1
drop cascades to table gc1
DROP TABLE
-- test attinhcount tracking with merged columns
create table depth0();
CREATE TABLE
create table depth1(c text) inherits (depth0);
CREATE TABLE
create table depth2() inherits (depth1);
CREATE TABLE
alter table depth0 add c text;
NOTICE:  00000: merging definition of column "c" for child "depth1"
ALTER TABLE
select attrelid::regclass, attname, attinhcount, attislocal
from pg_attribute
where attnum > 0 and attrelid::regclass in ('depth0', 'depth1', 'depth2')
order by attrelid::regclass::text, attnum;
 attrelid | attname | attinhcount | attislocal 
----------+---------+-------------+------------
 depth0   | c       |           0 | t
 depth1   | c       |           1 | t
 depth2   | c       |           1 | f
(3 rows)

--
-- Test the ALTER TABLE SET WITH/WITHOUT OIDS command
--
create table altstartwith (col integer) with oids;
CREATE TABLE
insert into altstartwith values (1);
INSERT 35945 1
select oid > 0, * from altstartwith;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

alter table altstartwith set without oids;
ALTER TABLE
select oid > 0, * from altstartwith; -- fails
ERROR:  42703: column "oid" does not exist
LINE 1: select oid > 0, * from altstartwith;
               ^
select * from altstartwith;
 col 
-----
   1
(1 row)

alter table altstartwith set with oids;
ALTER TABLE
select oid > 0, * from altstartwith;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

drop table altstartwith;
DROP TABLE
-- Check inheritance cases
create table altwithoid (col integer) with oids;
CREATE TABLE
-- Inherits parents oid column anyway
create table altinhoid () inherits (altwithoid) without oids;
CREATE TABLE
insert into altinhoid values (1);
INSERT 35959 1
select oid > 0, * from altwithoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

select oid > 0, * from altinhoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

alter table altwithoid set without oids;
ALTER TABLE
select oid > 0, * from altwithoid; -- fails
ERROR:  42703: column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid; -- fails
ERROR:  42703: column "oid" does not exist
LINE 1: select oid > 0, * from altinhoid;
               ^
select * from altwithoid;
 col 
-----
   1
(1 row)

select * from altinhoid;
 col 
-----
   1
(1 row)

alter table altwithoid set with oids;
ALTER TABLE
select oid > 0, * from altwithoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

select oid > 0, * from altinhoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

drop table altwithoid cascade;
NOTICE:  00000: drop cascades to table altinhoid
DROP TABLE
create table altwithoid (col integer) without oids;
CREATE TABLE
-- child can have local oid column
create table altinhoid () inherits (altwithoid) with oids;
CREATE TABLE
insert into altinhoid values (1);
INSERT 35979 1
select oid > 0, * from altwithoid; -- fails
ERROR:  42703: column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

alter table altwithoid set with oids;
NOTICE:  00000: merging definition of column "oid" for child "altinhoid"
ALTER TABLE
select oid > 0, * from altwithoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

select oid > 0, * from altinhoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

-- the child's local definition should remain
alter table altwithoid set without oids;
ALTER TABLE
select oid > 0, * from altwithoid; -- fails
ERROR:  42703: column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid;
 ?column? | col 
----------+-----
 t        |   1
(1 row)

drop table altwithoid cascade;
NOTICE:  00000: drop cascades to table altinhoid
DROP TABLE
-- test renumbering of child-table columns in inherited operations
create table p1 (f1 int);
CREATE TABLE
create table c1 (f2 text, f3 int) inherits (p1);
CREATE TABLE
alter table p1 add column a1 int check (a1 > 0);
ALTER TABLE
alter table p1 add column f2 text;
NOTICE:  00000: merging definition of column "f2" for child "c1"
ALTER TABLE
insert into p1 values (1,2,'abc');
INSERT 0 1
insert into c1 values(11,'xyz',33,0); -- should fail
ERROR:  23514: new row for relation "c1" violates check constraint "p1_a1_check"
DETAIL:  Failing row contains (11, xyz, 33, 0).
insert into c1 values(11,'xyz',33,22);
INSERT 0 1
select * from p1;
 f1 | a1 | f2  
----+----+-----
  1 |  2 | abc
 11 | 22 | xyz
(2 rows)

update p1 set a1 = a1 + 1, f2 = upper(f2);
UPDATE 2
select * from p1;
 f1 | a1 | f2  
----+----+-----
  1 |  3 | ABC
 11 | 23 | XYZ
(2 rows)

drop table p1 cascade;
NOTICE:  00000: drop cascades to table c1
DROP TABLE
-- test that operations with a dropped column do not try to reference
-- its datatype
create domain mytype as text;
CREATE DOMAIN
create temp table foo (f1 text, f2 mytype, f3 text);
CREATE TABLE
insert into foo values('bb','cc','dd');
INSERT 0 1
select * from foo;
 f1 | f2 | f3 
----+----+----
 bb | cc | dd
(1 row)

drop domain mytype cascade;
NOTICE:  00000: drop cascades to table foo column f2
DROP DOMAIN
select * from foo;
 f1 | f3 
----+----
 bb | dd
(1 row)

insert into foo values('qq','rr');
INSERT 0 1
select * from foo;
 f1 | f3 
----+----
 bb | dd
 qq | rr
(2 rows)

update foo set f3 = 'zz';
UPDATE 2
select * from foo;
 f1 | f3 
----+----
 bb | zz
 qq | zz
(2 rows)

select f3,max(f1) from foo group by f3;
 f3 | max 
----+-----
 zz | qq
(1 row)

-- Simple tests for alter table column type
alter table foo alter f1 TYPE integer; -- fails
ERROR:  42804: column "f1" cannot be cast automatically to type integer
HINT:  You might need to specify "USING f1::integer".
alter table foo alter f1 TYPE varchar(10);
ALTER TABLE
create table anothertab (atcol1 serial8, atcol2 boolean,
	constraint anothertab_chk check (atcol1 <= 3));
CREATE TABLE
insert into anothertab (atcol1, atcol2) values (default, true);
INSERT 0 1
insert into anothertab (atcol1, atcol2) values (default, false);
INSERT 0 1
select * from anothertab;
 atcol1 | atcol2 
--------+--------
      1 | t
      2 | f
(2 rows)

alter table anothertab alter column atcol1 type boolean; -- fails
ERROR:  42804: column "atcol1" cannot be cast automatically to type boolean
HINT:  You might need to specify "USING atcol1::boolean".
alter table anothertab alter column atcol1 type boolean using atcol1::int; -- fails
ERROR:  42804: result of USING clause for column "atcol1" cannot be cast automatically to type boolean
HINT:  You might need to add an explicit cast.
alter table anothertab alter column atcol1 type integer;
ALTER TABLE
select * from anothertab;
 atcol1 | atcol2 
--------+--------
      1 | t
      2 | f
(2 rows)

insert into anothertab (atcol1, atcol2) values (45, null); -- fails
ERROR:  23514: new row for relation "anothertab" violates check constraint "anothertab_chk"
DETAIL:  Failing row contains (45, null).
insert into anothertab (atcol1, atcol2) values (default, null);
INSERT 0 1
select * from anothertab;
 atcol1 | atcol2 
--------+--------
      1 | t
      2 | f
      3 | 
(3 rows)

alter table anothertab alter column atcol2 type text
      using case when atcol2 is true then 'IT WAS TRUE'
                 when atcol2 is false then 'IT WAS FALSE'
                 else 'IT WAS NULL!' end;
ALTER TABLE
select * from anothertab;
 atcol1 |    atcol2    
--------+--------------
      1 | IT WAS TRUE
      2 | IT WAS FALSE
      3 | IT WAS NULL!
(3 rows)

alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end; -- fails
ERROR:  42804: default for column "atcol1" cannot be cast automatically to type boolean
alter table anothertab alter column atcol1 drop default;
ALTER TABLE
alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end; -- fails
ERROR:  42883: operator does not exist: boolean <= integer
HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
alter table anothertab drop constraint anothertab_chk;
ALTER TABLE
alter table anothertab drop constraint anothertab_chk; -- fails
ERROR:  42704: constraint "anothertab_chk" of relation "anothertab" does not exist
alter table anothertab drop constraint IF EXISTS anothertab_chk; -- succeeds
NOTICE:  00000: constraint "anothertab_chk" of relation "anothertab" does not exist, skipping
ALTER TABLE
alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end;
ALTER TABLE
select * from anothertab;
 atcol1 |    atcol2    
--------+--------------
 f      | IT WAS TRUE
 t      | IT WAS FALSE
 f      | IT WAS NULL!
(3 rows)

drop table anothertab;
DROP TABLE
create table another (f1 int, f2 text);
CREATE TABLE
insert into another values(1, 'one');
INSERT 0 1
insert into another values(2, 'two');
INSERT 0 1
insert into another values(3, 'three');
INSERT 0 1
select * from another;
 f1 |  f2   
----+-------
  1 | one
  2 | two
  3 | three
(3 rows)

alter table another
  alter f1 type text using f2 || ' more',
  alter f2 type bigint using f1 * 10;
ALTER TABLE
select * from another;
     f1     | f2 
------------+----
 one more   | 10
 two more   | 20
 three more | 30
(3 rows)

drop table another;
DROP TABLE
-- table's row type
create table tab1 (a int, b text);
CREATE TABLE
create table tab2 (x int, y tab1);
CREATE TABLE
alter table tab1 alter column b type varchar; -- fails
ERROR:  0A000: cannot alter table "tab1" because column "tab2.y" uses its row type
-- disallow recursive containment of row types
create temp table recur1 (f1 int);
CREATE TABLE
alter table recur1 add column f2 recur1; -- fails
ERROR:  42P16: composite type recur1 cannot be made a member of itself
alter table recur1 add column f2 recur1[]; -- fails
ERROR:  42P16: composite type recur1 cannot be made a member of itself
create domain array_of_recur1 as recur1[];
CREATE DOMAIN
alter table recur1 add column f2 array_of_recur1; -- fails
ERROR:  42P16: composite type recur1 cannot be made a member of itself
create temp table recur2 (f1 int, f2 recur1);
CREATE TABLE
alter table recur1 add column f2 recur2; -- fails
ERROR:  42P16: composite type recur1 cannot be made a member of itself
alter table recur1 add column f2 int;
ALTER TABLE
alter table recur1 alter column f2 type recur2; -- fails
ERROR:  42P16: composite type recur1 cannot be made a member of itself
-- SET STORAGE may need to add a TOAST table
create table test_storage (a text);
CREATE TABLE
alter table test_storage alter a set storage plain;
ALTER TABLE
alter table test_storage add b int default 0; -- rewrite table to remove its TOAST table
ALTER TABLE
alter table test_storage alter a set storage extended; -- re-add TOAST table
ALTER TABLE
select reltoastrelid <> 0 as has_toast_table
from pg_class
where oid = 'test_storage'::regclass;
 has_toast_table 
-----------------
 t
(1 row)

-- ALTER COLUMN TYPE with a check constraint and a child table (bug #13779)
CREATE TABLE test_inh_check (a float check (a > 10.2), b float);
CREATE TABLE
CREATE TABLE test_inh_check_child() INHERITS(test_inh_check);
CREATE TABLE
\d test_inh_check
     Table "public.test_inh_check"
 Column |       Type       | Modifiers 
--------+------------------+-----------
 a      | double precision | 
 b      | double precision | 
Check constraints:
    "test_inh_check_a_check" CHECK (a > 10.2::double precision)

\d test_inh_check_child
  Table "public.test_inh_check_child"
 Column |       Type       | Modifiers 
--------+------------------+-----------
 a      | double precision | 
 b      | double precision | 
Check constraints:
    "test_inh_check_a_check" CHECK (a > 10.2::double precision)
Inherits: test_inh_check

select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2;
       relname        |        conname         | coninhcount | conislocal | connoinherit 
----------------------+------------------------+-------------+------------+--------------
 test_inh_check       | test_inh_check_a_check |           0 | t          | f
 test_inh_check_child | test_inh_check_a_check |           1 | f          | f
(2 rows)

ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
ALTER TABLE
\d test_inh_check
     Table "public.test_inh_check"
 Column |       Type       | Modifiers 
--------+------------------+-----------
 a      | numeric          | 
 b      | double precision | 
Check constraints:
    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)

\d test_inh_check_child
  Table "public.test_inh_check_child"
 Column |       Type       | Modifiers 
--------+------------------+-----------
 a      | numeric          | 
 b      | double precision | 
Check constraints:
    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
Inherits: test_inh_check

select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2;
       relname        |        conname         | coninhcount | conislocal | connoinherit 
----------------------+------------------------+-------------+------------+--------------
 test_inh_check       | test_inh_check_a_check |           0 | t          | f
 test_inh_check_child | test_inh_check_a_check |           1 | f          | f
(2 rows)

-- also try noinherit, local, and local+inherited cases
ALTER TABLE test_inh_check ADD CONSTRAINT bnoinherit CHECK (b > 100) NO INHERIT;
ALTER TABLE
ALTER TABLE test_inh_check_child ADD CONSTRAINT blocal CHECK (b < 1000);
ALTER TABLE
ALTER TABLE test_inh_check_child ADD CONSTRAINT bmerged CHECK (b > 1);
ALTER TABLE
ALTER TABLE test_inh_check ADD CONSTRAINT bmerged CHECK (b > 1);
NOTICE:  00000: merging constraint "bmerged" with inherited definition
ALTER TABLE
\d test_inh_check
     Table "public.test_inh_check"
 Column |       Type       | Modifiers 
--------+------------------+-----------
 a      | numeric          | 
 b      | double precision | 
Check constraints:
    "bmerged" CHECK (b > 1::double precision)
    "bnoinherit" CHECK (b > 100::double precision) NO INHERIT
    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)

\d test_inh_check_child
  Table "public.test_inh_check_child"
 Column |       Type       | Modifiers 
--------+------------------+-----------
 a      | numeric          | 
 b      | double precision | 
Check constraints:
    "blocal" CHECK (b < 1000::double precision)
    "bmerged" CHECK (b > 1::double precision)
    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
Inherits: test_inh_check

select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2;
       relname        |        conname         | coninhcount | conislocal | connoinherit 
----------------------+------------------------+-------------+------------+--------------
 test_inh_check       | bmerged                |           0 | t          | f
 test_inh_check       | bnoinherit             |           0 | t          | t
 test_inh_check       | test_inh_check_a_check |           0 | t          | f
 test_inh_check_child | blocal                 |           0 | t          | f
 test_inh_check_child | bmerged                |           1 | t          | f
 test_inh_check_child | test_inh_check_a_check |           1 | f          | f
(6 rows)

ALTER TABLE test_inh_check ALTER COLUMN b TYPE numeric;
NOTICE:  00000: merging constraint "bmerged" with inherited definition
ALTER TABLE
\d test_inh_check
Table "public.test_inh_check"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | numeric | 
 b      | numeric | 
Check constraints:
    "bmerged" CHECK (b::double precision > 1::double precision)
    "bnoinherit" CHECK (b::double precision > 100::double precision) NO INHERIT
    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)

\d test_inh_check_child
Table "public.test_inh_check_child"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | numeric | 
 b      | numeric | 
Check constraints:
    "blocal" CHECK (b::double precision < 1000::double precision)
    "bmerged" CHECK (b::double precision > 1::double precision)
    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
Inherits: test_inh_check

select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2;
       relname        |        conname         | coninhcount | conislocal | connoinherit 
----------------------+------------------------+-------------+------------+--------------
 test_inh_check       | bmerged                |           0 | t          | f
 test_inh_check       | bnoinherit             |           0 | t          | t
 test_inh_check       | test_inh_check_a_check |           0 | t          | f
 test_inh_check_child | blocal                 |           0 | t          | f
 test_inh_check_child | bmerged                |           1 | t          | f
 test_inh_check_child | test_inh_check_a_check |           1 | f          | f
(6 rows)

-- ALTER COLUMN TYPE with different schema in children
-- Bug at https://postgr.es/m/20170102225618.GA10071@telsasoft.com
CREATE TABLE test_type_diff (f1 int);
CREATE TABLE
CREATE TABLE test_type_diff_c (extra smallint) INHERITS (test_type_diff);
CREATE TABLE
ALTER TABLE test_type_diff ADD COLUMN f2 int;
ALTER TABLE
INSERT INTO test_type_diff_c VALUES (1, 2, 3);
INSERT 0 1
ALTER TABLE test_type_diff ALTER COLUMN f2 TYPE bigint USING f2::bigint;
ALTER TABLE
CREATE TABLE test_type_diff2 (int_two int2, int_four int4, int_eight int8);
CREATE TABLE
CREATE TABLE test_type_diff2_c1 (int_four int4, int_eight int8, int_two int2);
CREATE TABLE
CREATE TABLE test_type_diff2_c2 (int_eight int8, int_two int2, int_four int4);
CREATE TABLE
CREATE TABLE test_type_diff2_c3 (int_two int2, int_four int4, int_eight int8);
CREATE TABLE
ALTER TABLE test_type_diff2_c1 INHERIT test_type_diff2;
ALTER TABLE
ALTER TABLE test_type_diff2_c2 INHERIT test_type_diff2;
ALTER TABLE
ALTER TABLE test_type_diff2_c3 INHERIT test_type_diff2;
ALTER TABLE
INSERT INTO test_type_diff2_c1 VALUES (1, 2, 3);
INSERT 0 1
INSERT INTO test_type_diff2_c2 VALUES (4, 5, 6);
INSERT 0 1
INSERT INTO test_type_diff2_c3 VALUES (7, 8, 9);
INSERT 0 1
ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int8 USING int_four::int8;
ALTER TABLE
-- whole-row references are disallowed
ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int4 USING (pg_column_size(test_type_diff2));
ERROR:  0A000: cannot convert whole-row table reference
DETAIL:  USING expression contains a whole-row table reference.
-- check for rollback of ANALYZE corrupting table property flags (bug #11638)
CREATE TABLE check_fk_presence_1 (id int PRIMARY KEY, t text);
CREATE TABLE
CREATE TABLE check_fk_presence_2 (id int REFERENCES check_fk_presence_1, t text);
CREATE TABLE
BEGIN;
BEGIN
ALTER TABLE check_fk_presence_2 DROP CONSTRAINT check_fk_presence_2_id_fkey;
ALTER TABLE
ANALYZE check_fk_presence_2;
ANALYZE
ROLLBACK;
ROLLBACK
\d check_fk_presence_2
Table "public.check_fk_presence_2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 id     | integer | 
 t      | text    | 
Foreign-key constraints:
    "check_fk_presence_2_id_fkey" FOREIGN KEY (id) REFERENCES check_fk_presence_1(id)

DROP TABLE check_fk_presence_1, check_fk_presence_2;
DROP TABLE
-- check column addition within a view (bug #14876)
create table at_base_table(id int, stuff text);
CREATE TABLE
insert into at_base_table values (23, 'skidoo');
INSERT 0 1
create view at_view_1 as select * from at_base_table bt;
CREATE VIEW
create view at_view_2 as select *, to_json(v1) as j from at_view_1 v1;
CREATE VIEW
\d+ at_view_1
                View "public.at_view_1"
 Column |  Type   | Modifiers | Storage  | Description 
--------+---------+-----------+----------+-------------
 id     | integer |           | plain    | 
 stuff  | text    |           | extended | 
View definition:
 SELECT bt.id,
    bt.stuff
   FROM at_base_table bt;

\d+ at_view_2
                View "public.at_view_2"
 Column |  Type   | Modifiers | Storage  | Description 
--------+---------+-----------+----------+-------------
 id     | integer |           | plain    | 
 stuff  | text    |           | extended | 
 j      | json    |           | extended | 
View definition:
 SELECT v1.id,
    v1.stuff,
    to_json(v1.*) AS j
   FROM at_view_1 v1;

explain (verbose, costs off) select * from at_view_2;
                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on public.at_base_table bt
   Output: bt.id, bt.stuff, to_json(ROW(bt.id, bt.stuff))
(2 rows)

select * from at_view_2;
 id | stuff  |             j              
----+--------+----------------------------
 23 | skidoo | {"id":23,"stuff":"skidoo"}
(1 row)

create or replace view at_view_1 as select *, 2+2 as more from at_base_table bt;
CREATE VIEW
\d+ at_view_1
                View "public.at_view_1"
 Column |  Type   | Modifiers | Storage  | Description 
--------+---------+-----------+----------+-------------
 id     | integer |           | plain    | 
 stuff  | text    |           | extended | 
 more   | integer |           | plain    | 
View definition:
 SELECT bt.id,
    bt.stuff,
    2 + 2 AS more
   FROM at_base_table bt;

\d+ at_view_2
                View "public.at_view_2"
 Column |  Type   | Modifiers | Storage  | Description 
--------+---------+-----------+----------+-------------
 id     | integer |           | plain    | 
 stuff  | text    |           | extended | 
 j      | json    |           | extended | 
View definition:
 SELECT v1.id,
    v1.stuff,
    to_json(v1.*) AS j
   FROM at_view_1 v1;

explain (verbose, costs off) select * from at_view_2;
                           QUERY PLAN                           
----------------------------------------------------------------
 Seq Scan on public.at_base_table bt
   Output: bt.id, bt.stuff, to_json(ROW(bt.id, bt.stuff, NULL))
(2 rows)

select * from at_view_2;
 id | stuff  |                   j                    
----+--------+----------------------------------------
 23 | skidoo | {"id":23,"stuff":"skidoo","more":null}
(1 row)

drop view at_view_2;
DROP VIEW
drop view at_view_1;
DROP VIEW
drop table at_base_table;
DROP TABLE
--
-- lock levels
--
drop type lockmodes;
ERROR:  42704: type "lockmodes" does not exist
create type lockmodes as enum (
 'SIReadLock'
,'AccessShareLock'
,'RowShareLock'
,'RowExclusiveLock'
,'ShareUpdateExclusiveLock'
,'ShareLock'
,'ShareRowExclusiveLock'
,'ExclusiveLock'
,'AccessExclusiveLock'
);
CREATE TYPE
drop view my_locks;
ERROR:  42P01: view "my_locks" does not exist
create or replace view my_locks as
select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
from pg_locks l join pg_class c on l.relation = c.oid
where virtualtransaction = (
        select virtualtransaction
        from pg_locks
        where transactionid = txid_current()::integer)
and locktype = 'relation'
and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
and c.relname != 'my_locks'
group by c.relname;
CREATE VIEW
create table alterlock (f1 int primary key, f2 text);
CREATE TABLE
insert into alterlock values (1, 'foo');
INSERT 0 1
create table alterlock2 (f3 int primary key, f1 int);
CREATE TABLE
insert into alterlock2 values (1, 1);
INSERT 0 1
begin; alter table alterlock alter column f2 set statistics 150;
BEGIN
ALTER TABLE
select * from my_locks order by 1;
  relname  |       max_lockmode       
-----------+--------------------------
 alterlock | ShareUpdateExclusiveLock
(1 row)

rollback;
ROLLBACK
begin; alter table alterlock cluster on alterlock_pkey;
BEGIN
ALTER TABLE
select * from my_locks order by 1;
    relname     |       max_lockmode       
----------------+--------------------------
 alterlock      | ShareUpdateExclusiveLock
 alterlock_pkey | ShareUpdateExclusiveLock
(2 rows)

commit;
COMMIT
begin; alter table alterlock set without cluster;
BEGIN
ALTER TABLE
select * from my_locks order by 1;
  relname  |       max_lockmode       
-----------+--------------------------
 alterlock | ShareUpdateExclusiveLock
(1 row)

commit;
COMMIT
begin; alter table alterlock set (fillfactor = 100);
BEGIN
ALTER TABLE
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
 pg_toast  | AccessExclusiveLock
(2 rows)

commit;
COMMIT
begin; alter table alterlock reset (fillfactor);
BEGIN
ALTER TABLE
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
 pg_toast  | AccessExclusiveLock
(2 rows)

commit;
COMMIT
begin; alter table alterlock set (toast.autovacuum_enabled = off);
BEGIN
ALTER TABLE
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
 pg_toast  | AccessExclusiveLock
(2 rows)

commit;
COMMIT
begin; alter table alterlock set (autovacuum_enabled = off);
BEGIN
ALTER TABLE
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
 pg_toast  | AccessExclusiveLock
(2 rows)

commit;
COMMIT
begin; alter table alterlock alter column f2 set (n_distinct = 1);
BEGIN
ALTER TABLE
select * from my_locks order by 1;
  relname  |       max_lockmode       
-----------+--------------------------
 alterlock | ShareUpdateExclusiveLock
(1 row)

rollback;
ROLLBACK
begin; alter table alterlock alter column f2 set storage extended;
BEGIN
ALTER TABLE
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
(1 row)

rollback;
ROLLBACK
begin; alter table alterlock alter column f2 set default 'x';
BEGIN
ALTER TABLE
select * from my_locks order by 1;
  relname  |    max_lockmode     
-----------+---------------------
 alterlock | AccessExclusiveLock
(1 row)

rollback;
ROLLBACK
begin;
BEGIN
create trigger ttdummy
	before delete or update on alterlock
	for each row
	execute procedure
	ttdummy (1, 1);
ERROR:  42883: function ttdummy() does not exist
select * from my_locks order by 1;
ERROR:  25P02: current transaction is aborted, commands ignored until end of transaction block
rollback;
ROLLBACK
begin;
BEGIN
select * from my_locks order by 1;
 relname | max_lockmode 
---------+--------------
(0 rows)

alter table alterlock2 add foreign key (f1) references alterlock (f1);
ALTER TABLE
select * from my_locks order by 1;
     relname     |     max_lockmode      
-----------------+-----------------------
 alterlock       | ShareRowExclusiveLock
 alterlock2      | ShareRowExclusiveLock
 alterlock2_pkey | AccessShareLock
 alterlock_pkey  | AccessShareLock
(4 rows)

rollback;
ROLLBACK
begin;
BEGIN
alter table alterlock2
add constraint alterlock2nv foreign key (f1) references alterlock (f1) NOT VALID;
ALTER TABLE
select * from my_locks order by 1;
  relname   |     max_lockmode      
------------+-----------------------
 alterlock  | ShareRowExclusiveLock
 alterlock2 | ShareRowExclusiveLock
(2 rows)

commit;
COMMIT
begin;
BEGIN
alter table alterlock2 validate constraint alterlock2nv;
ALTER TABLE
select * from my_locks order by 1;
     relname     |       max_lockmode       
-----------------+--------------------------
 alterlock       | RowShareLock
 alterlock2      | ShareUpdateExclusiveLock
 alterlock2_pkey | AccessShareLock
 alterlock_pkey  | AccessShareLock
(4 rows)

rollback;
ROLLBACK
-- cleanup
drop table alterlock2;
DROP TABLE
drop table alterlock;
DROP TABLE
drop view my_locks;
DROP VIEW
drop type lockmodes;
DROP TYPE
--
-- alter function
--
create function test_strict(text) returns text as
    'select coalesce($1, ''got passed a null'');'
    language sql returns null on null input;
CREATE FUNCTION
select test_strict(NULL);
 test_strict 
-------------
 
(1 row)

alter function test_strict(text) called on null input;
ALTER FUNCTION
select test_strict(NULL);
    test_strict    
-------------------
 got passed a null
(1 row)

create function non_strict(text) returns text as
    'select coalesce($1, ''got passed a null'');'
    language sql called on null input;
CREATE FUNCTION
select non_strict(NULL);
    non_strict     
-------------------
 got passed a null
(1 row)

alter function non_strict(text) returns null on null input;
ALTER FUNCTION
select non_strict(NULL);
 non_strict 
------------
 
(1 row)

--
-- alter object set schema
--
create schema alter1;
CREATE SCHEMA
create schema alter2;
CREATE SCHEMA
create table alter1.t1(f1 serial primary key, f2 int check (f2 > 0));
CREATE TABLE
create view alter1.v1 as select * from alter1.t1;
CREATE VIEW
create function alter1.plus1(int) returns int as 'select $1+1' language sql;
CREATE FUNCTION
create domain alter1.posint integer check (value > 0);
CREATE DOMAIN
create type alter1.ctype as (f1 int, f2 text);
CREATE TYPE
create function alter1.same(alter1.ctype, alter1.ctype) returns boolean language sql
as 'select $1.f1 is not distinct from $2.f1 and $1.f2 is not distinct from $2.f2';
CREATE FUNCTION
create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype);
CREATE OPERATOR
create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as
  operator 1 alter1.=(alter1.ctype, alter1.ctype);
CREATE OPERATOR CLASS
create conversion alter1.ascii_to_utf8 for 'sql_ascii' to 'utf8' from ascii_to_utf8;
CREATE CONVERSION
create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
CREATE TEXT SEARCH PARSER
create text search configuration alter1.cfg(parser = alter1.prs);
CREATE TEXT SEARCH CONFIGURATION
create text search template alter1.tmpl(init = dsimple_init, lexize = dsimple_lexize);
CREATE TEXT SEARCH TEMPLATE
create text search dictionary alter1.dict(template = alter1.tmpl);
CREATE TEXT SEARCH DICTIONARY
insert into alter1.t1(f2) values(11);
INSERT 0 1
insert into alter1.t1(f2) values(12);
INSERT 0 1
alter table alter1.t1 set schema alter2;
ALTER TABLE
alter table alter1.v1 set schema alter2;
ALTER TABLE
alter function alter1.plus1(int) set schema alter2;
ALTER FUNCTION
alter domain alter1.posint set schema alter2;
ALTER DOMAIN
alter operator class alter1.ctype_hash_ops using hash set schema alter2;
ALTER OPERATOR CLASS
alter operator family alter1.ctype_hash_ops using hash set schema alter2;
ALTER OPERATOR FAMILY
alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2;
ALTER OPERATOR
alter function alter1.same(alter1.ctype, alter1.ctype) set schema alter2;
ALTER FUNCTION
alter type alter1.ctype set schema alter2;
ALTER TYPE
alter conversion alter1.ascii_to_utf8 set schema alter2;
ALTER CONVERSION
alter text search parser alter1.prs set schema alter2;
ALTER TEXT SEARCH PARSER
alter text search configuration alter1.cfg set schema alter2;
ALTER TEXT SEARCH CONFIGURATION
alter text search template alter1.tmpl set schema alter2;
ALTER TEXT SEARCH TEMPLATE
alter text search dictionary alter1.dict set schema alter2;
ALTER TEXT SEARCH DICTIONARY
-- this should succeed because nothing is left in alter1
drop schema alter1;
DROP SCHEMA
insert into alter2.t1(f2) values(13);
INSERT 0 1
insert into alter2.t1(f2) values(14);
INSERT 0 1
select * from alter2.t1;
 f1 | f2 
----+----
  1 | 11
  2 | 12
  3 | 13
  4 | 14
(4 rows)

select * from alter2.v1;
 f1 | f2 
----+----
  1 | 11
  2 | 12
  3 | 13
  4 | 14
(4 rows)

select alter2.plus1(41);
 plus1 
-------
    42
(1 row)

-- clean up
drop schema alter2 cascade;
NOTICE:  00000: drop cascades to 13 other objects
DETAIL:  drop cascades to table alter2.t1
drop cascades to view alter2.v1
drop cascades to function alter2.plus1(integer)
drop cascades to type alter2.posint
drop cascades to operator family alter2.ctype_hash_ops for access method hash
drop cascades to type alter2.ctype
drop cascades to function alter2.same(alter2.ctype,alter2.ctype)
drop cascades to operator alter2.=(alter2.ctype,alter2.ctype)
drop cascades to conversion ascii_to_utf8
drop cascades to text search parser prs
drop cascades to text search configuration cfg
drop cascades to text search template tmpl
drop cascades to text search dictionary dict
DROP SCHEMA
--
-- composite types
--
CREATE TYPE test_type AS (a int);
CREATE TYPE
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 

ALTER TYPE nosuchtype ADD ATTRIBUTE b text; -- fails
ERROR:  42P01: relation "nosuchtype" does not exist
ALTER TYPE test_type ADD ATTRIBUTE b text;
ALTER TYPE
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | text    | 

ALTER TYPE test_type ADD ATTRIBUTE b text; -- fails
ERROR:  42701: column "b" of relation "test_type" already exists
ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
ALTER TYPE
\d test_type
   Composite type "public.test_type"
 Column |       Type        | Modifiers 
--------+-------------------+-----------
 a      | integer           | 
 b      | character varying | 

ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer;
ALTER TYPE
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 

ALTER TYPE test_type DROP ATTRIBUTE b;
ALTER TYPE
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 

ALTER TYPE test_type DROP ATTRIBUTE c; -- fails
ERROR:  42703: column "c" of relation "test_type" does not exist
ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
NOTICE:  00000: column "c" of relation "test_type" does not exist, skipping
ALTER TYPE
ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
ALTER TYPE
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 d      | boolean | 

ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
ERROR:  42703: column "a" does not exist
ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
ALTER TYPE
\d test_type
Composite type "public.test_type"
 Column |  Type   | Modifiers 
--------+---------+-----------
 dd     | boolean | 

DROP TYPE test_type;
DROP TYPE
CREATE TYPE test_type1 AS (a int, b text);
CREATE TYPE
CREATE TABLE test_tbl1 (x int, y test_type1);
CREATE TABLE
ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar; -- fails
ERROR:  0A000: cannot alter type "test_type1" because column "test_tbl1.y" uses it
CREATE TYPE test_type2 AS (a int, b text);
CREATE TYPE
CREATE TABLE test_tbl2 OF test_type2;
CREATE TABLE
CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2);
CREATE TABLE
\d test_type2
Composite type "public.test_type2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | text    | 

\d test_tbl2
   Table "public.test_tbl2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | text    | 
Typed table of type: test_type2

ALTER TYPE test_type2 ADD ATTRIBUTE c text; -- fails
ERROR:  2BP01: cannot alter type "test_type2" because it is the type of a typed table
HINT:  Use ALTER ... CASCADE to alter the typed tables too.
ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
ALTER TYPE
\d test_type2
Composite type "public.test_type2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | text    | 
 c      | text    | 

\d test_tbl2
   Table "public.test_tbl2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | text    | 
 c      | text    | 
Typed table of type: test_type2

ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; -- fails
ERROR:  2BP01: cannot alter type "test_type2" because it is the type of a typed table
HINT:  Use ALTER ... CASCADE to alter the typed tables too.
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
ALTER TYPE
\d test_type2
   Composite type "public.test_type2"
 Column |       Type        | Modifiers 
--------+-------------------+-----------
 a      | integer           | 
 b      | character varying | 
 c      | text              | 

\d test_tbl2
        Table "public.test_tbl2"
 Column |       Type        | Modifiers 
--------+-------------------+-----------
 a      | integer           | 
 b      | character varying | 
 c      | text              | 
Typed table of type: test_type2

ALTER TYPE test_type2 DROP ATTRIBUTE b; -- fails
ERROR:  2BP01: cannot alter type "test_type2" because it is the type of a typed table
HINT:  Use ALTER ... CASCADE to alter the typed tables too.
ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
ALTER TYPE
\d test_type2
Composite type "public.test_type2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 c      | text    | 

\d test_tbl2
   Table "public.test_tbl2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 c      | text    | 
Typed table of type: test_type2

ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails
ERROR:  2BP01: cannot alter type "test_type2" because it is the type of a typed table
HINT:  Use ALTER ... CASCADE to alter the typed tables too.
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
ALTER TYPE
\d test_type2
Composite type "public.test_type2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 aa     | integer | 
 c      | text    | 

\d test_tbl2
   Table "public.test_tbl2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 aa     | integer | 
 c      | text    | 
Typed table of type: test_type2

\d test_tbl2_subclass
Table "public.test_tbl2_subclass"
 Column |  Type   | Modifiers 
--------+---------+-----------
 aa     | integer | 
 c      | text    | 
Inherits: test_tbl2

DROP TABLE test_tbl2_subclass;
DROP TABLE
CREATE TYPE test_typex AS (a int, b text);
CREATE TYPE
CREATE TABLE test_tblx (x int, y test_typex check ((y).a > 0));
CREATE TABLE
ALTER TYPE test_typex DROP ATTRIBUTE a; -- fails
ERROR:  2BP01: cannot drop composite type test_typex column a because other objects depend on it
DETAIL:  constraint test_tblx_y_check on table test_tblx depends on composite type test_typex column a
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
ALTER TYPE test_typex DROP ATTRIBUTE a CASCADE;
NOTICE:  00000: drop cascades to constraint test_tblx_y_check on table test_tblx
ALTER TYPE
\d test_tblx
    Table "public.test_tblx"
 Column |    Type    | Modifiers 
--------+------------+-----------
 x      | integer    | 
 y      | test_typex | 

DROP TABLE test_tblx;
DROP TABLE
DROP TYPE test_typex;
DROP TYPE
-- This test isn't that interesting on its own, but the purpose is to leave
-- behind a table to test pg_upgrade with. The table has a composite type
-- column in it, and the composite type has a dropped attribute.
CREATE TYPE test_type3 AS (a int);
CREATE TYPE
CREATE TABLE test_tbl3 (c) AS SELECT '(1)'::test_type3;
SELECT 1
ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;
ALTER TYPE
CREATE TYPE test_type_empty AS ();
CREATE TYPE
DROP TYPE test_type_empty;
DROP TYPE
--
-- typed tables: OF / NOT OF
--
CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));
CREATE TYPE
ALTER TYPE tt_t0 DROP ATTRIBUTE z;
ALTER TYPE
CREATE TABLE tt0 (x int NOT NULL, y numeric(8,2));	-- OK
CREATE TABLE
CREATE TABLE tt1 (x int, y bigint);					-- wrong base type
CREATE TABLE
CREATE TABLE tt2 (x int, y numeric(9,2));			-- wrong typmod
CREATE TABLE
CREATE TABLE tt3 (y numeric(8,2), x int);			-- wrong column order
CREATE TABLE
CREATE TABLE tt4 (x int);							-- too few columns
CREATE TABLE
CREATE TABLE tt5 (x int, y numeric(8,2), z int);	-- too few columns
CREATE TABLE
CREATE TABLE tt6 () INHERITS (tt0);					-- can't have a parent
CREATE TABLE
CREATE TABLE tt7 (x int, q text, y numeric(8,2)) WITH OIDS;
CREATE TABLE
ALTER TABLE tt7 DROP q;								-- OK
ALTER TABLE
ALTER TABLE tt0 OF tt_t0;
ALTER TABLE
ALTER TABLE tt1 OF tt_t0;
ERROR:  42804: table "tt1" has different type for column "y"
ALTER TABLE tt2 OF tt_t0;
ERROR:  42804: table "tt2" has different type for column "y"
ALTER TABLE tt3 OF tt_t0;
ERROR:  42804: table has column "y" where type requires "x"
ALTER TABLE tt4 OF tt_t0;
ERROR:  42804: table is missing column "y"
ALTER TABLE tt5 OF tt_t0;
ERROR:  42804: table has extra column "z"
ALTER TABLE tt6 OF tt_t0;
ERROR:  42809: typed tables cannot inherit
ALTER TABLE tt7 OF tt_t0;
ALTER TABLE
CREATE TYPE tt_t1 AS (x int, y numeric(8,2));
CREATE TYPE
ALTER TABLE tt7 OF tt_t1;			-- reassign an already-typed table
ALTER TABLE
ALTER TABLE tt7 NOT OF;
ALTER TABLE
\d tt7
        Table "public.tt7"
 Column |     Type     | Modifiers 
--------+--------------+-----------
 x      | integer      | 
 y      | numeric(8,2) | 

-- make sure we can drop a constraint on the parent but it remains on the child
CREATE TABLE test_drop_constr_parent (c text CHECK (c IS NOT NULL));
CREATE TABLE
CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent);
CREATE TABLE
ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT "test_drop_constr_parent_c_check";
ALTER TABLE
-- should fail
INSERT INTO test_drop_constr_child (c) VALUES (NULL);
ERROR:  23514: new row for relation "test_drop_constr_child" violates check constraint "test_drop_constr_parent_c_check"
DETAIL:  Failing row contains (null).
DROP TABLE test_drop_constr_parent CASCADE;
NOTICE:  00000: drop cascades to table test_drop_constr_child
DROP TABLE
--
-- IF EXISTS test
--
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
NOTICE:  00000: relation "tt8" does not exist, skipping
ALTER TABLE
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
NOTICE:  00000: relation "tt8" does not exist, skipping
ALTER TABLE
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
NOTICE:  00000: relation "tt8" does not exist, skipping
ALTER TABLE
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
NOTICE:  00000: relation "tt8" does not exist, skipping
ALTER TABLE
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
NOTICE:  00000: relation "tt8" does not exist, skipping
ALTER TABLE
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
NOTICE:  00000: relation "tt8" does not exist, skipping
ALTER TABLE
CREATE TABLE tt8(a int);
CREATE TABLE
CREATE SCHEMA alter2;
CREATE SCHEMA
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
ALTER TABLE
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
ALTER TABLE
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
ALTER TABLE
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
ALTER TABLE
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
ALTER TABLE
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
ALTER TABLE
\d alter2.tt8
          Table "alter2.tt8"
 Column |  Type   |     Modifiers      
--------+---------+--------------------
 a      | integer | 
 f1     | integer | not null default 0
Indexes:
    "xxx" PRIMARY KEY, btree (f1)
Check constraints:
    "tt8_f_check" CHECK (f1 >= 0 AND f1 <= 10)

DROP TABLE alter2.tt8;
DROP TABLE
DROP SCHEMA alter2;
DROP SCHEMA
-- Check that comments on constraints and indexes are not lost at ALTER TABLE.
CREATE TABLE comment_test (
  id int,
  positive_col int CHECK (positive_col > 0),
  indexed_col int,
  CONSTRAINT comment_test_pk PRIMARY KEY (id));
CREATE TABLE
CREATE INDEX comment_test_index ON comment_test(indexed_col);
CREATE INDEX
COMMENT ON COLUMN comment_test.id IS 'Column ''id'' on comment_test';
COMMENT
COMMENT ON INDEX comment_test_index IS 'Simple index on comment_test';
COMMENT
COMMENT ON CONSTRAINT comment_test_positive_col_check ON comment_test IS 'CHECK constraint on comment_test.positive_col';
COMMENT
COMMENT ON CONSTRAINT comment_test_pk ON comment_test IS 'PRIMARY KEY constraint of comment_test';
COMMENT
COMMENT ON INDEX comment_test_pk IS 'Index backing the PRIMARY KEY of comment_test';
COMMENT
SELECT col_description('comment_test'::regclass, 1) as comment;
           comment           
-----------------------------
 Column 'id' on comment_test
(1 row)

SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
       index        |                    comment                    
--------------------+-----------------------------------------------
 comment_test_index | Simple index on comment_test
 comment_test_pk    | Index backing the PRIMARY KEY of comment_test
(2 rows)

SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
           constraint            |                    comment                    
---------------------------------+-----------------------------------------------
 comment_test_pk                 | PRIMARY KEY constraint of comment_test
 comment_test_positive_col_check | CHECK constraint on comment_test.positive_col
(2 rows)

-- Change the datatype of all the columns. ALTER TABLE is optimized to not
-- rebuild an index if the new data type is binary compatible with the old
-- one. Check do a dummy ALTER TABLE that doesn't change the datatype
-- first, to test that no-op codepath, and another one that does.
ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE int;
ALTER TABLE
ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE text;
ALTER TABLE
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int;
ALTER TABLE
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
ALTER TABLE
ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE int;
ALTER TABLE
ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE bigint;
ALTER TABLE
-- Check that the comments are intact.
SELECT col_description('comment_test'::regclass, 1) as comment;
           comment           
-----------------------------
 Column 'id' on comment_test
(1 row)

SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
       index        |                    comment                    
--------------------+-----------------------------------------------
 comment_test_index | Simple index on comment_test
 comment_test_pk    | Index backing the PRIMARY KEY of comment_test
(2 rows)

SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
           constraint            |                    comment                    
---------------------------------+-----------------------------------------------
 comment_test_pk                 | PRIMARY KEY constraint of comment_test
 comment_test_positive_col_check | CHECK constraint on comment_test.positive_col
(2 rows)

-- Check compatibility for foreign keys and comments. This is done
-- separately as rebuilding the column type of the parent leads
-- to an error and would reduce the test scope.
CREATE TABLE comment_test_child (
  id text CONSTRAINT comment_test_child_fk REFERENCES comment_test);
CREATE TABLE
CREATE INDEX comment_test_child_fk ON comment_test_child(id);
CREATE INDEX
COMMENT ON COLUMN comment_test_child.id IS 'Column ''id'' on comment_test_child';
COMMENT
COMMENT ON INDEX comment_test_child_fk IS 'Index backing the FOREIGN KEY of comment_test_child';
COMMENT
COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'FOREIGN KEY constraint of comment_test_child';
COMMENT
-- Change column type of parent
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
ALTER TABLE
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int USING id::integer;
ERROR:  42804: foreign key constraint "comment_test_child_fk" cannot be implemented
DETAIL:  Key columns "id" and "id" are of incompatible types: text and integer.
-- Comments should be intact
SELECT col_description('comment_test_child'::regclass, 1) as comment;
              comment              
-----------------------------------
 Column 'id' on comment_test_child
(1 row)

SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
         index         |                       comment                       
-----------------------+-----------------------------------------------------
 comment_test_child_fk | Index backing the FOREIGN KEY of comment_test_child
(1 row)

SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
      constraint       |                   comment                    
-----------------------+----------------------------------------------
 comment_test_child_fk | FOREIGN KEY constraint of comment_test_child
(1 row)

-- Check that we map relation oids to filenodes and back correctly.  Only
-- display bad mappings so the test output doesn't change all the time.  A
-- filenode function call can return NULL for a relation dropped concurrently
-- with the call's surrounding query, so ignore a NULL mapped_oid for
-- relations that no longer exist after all calls finish.
CREATE TEMP TABLE filenode_mapping AS
SELECT
    oid, mapped_oid, reltablespace, relfilenode, relname
FROM pg_class,
    pg_filenode_relation(reltablespace, pg_relation_filenode(oid)) AS mapped_oid
WHERE relkind IN ('r', 'i', 'S', 't', 'm') AND mapped_oid IS DISTINCT FROM oid;
SELECT 0
SELECT m.* FROM filenode_mapping m LEFT JOIN pg_class c ON c.oid = m.oid
WHERE c.oid IS NOT NULL OR m.mapped_oid IS NOT NULL;
 oid | mapped_oid | reltablespace | relfilenode | relname 
-----+------------+---------------+-------------+---------
(0 rows)

-- Checks on creating and manipulation of user defined relations in
-- pg_catalog.
--
-- XXX: It would be useful to add checks around trying to manipulate
-- catalog tables, but that might have ugly consequences when run
-- against an existing server with allow_system_table_mods = on.
SHOW allow_system_table_mods;
 allow_system_table_mods 
-------------------------
 off
(1 row)

-- disallowed because of search_path issues with pg_dump
CREATE TABLE pg_catalog.new_system_table();
ERROR:  42501: permission denied to create "pg_catalog.new_system_table"
DETAIL:  System catalog modifications are currently disallowed.
-- instead create in public first, move to catalog
CREATE TABLE new_system_table(id serial primary key, othercol text);
CREATE TABLE
ALTER TABLE new_system_table SET SCHEMA pg_catalog;
ALTER TABLE
-- XXX: it's currently impossible to move relations out of pg_catalog
ALTER TABLE new_system_table SET SCHEMA public;
ERROR:  0A000: cannot remove dependency on schema pg_catalog because it is a system object
-- move back, will currently error out, already there
ALTER TABLE new_system_table SET SCHEMA pg_catalog;
ERROR:  42P07: table new_system_table is already in schema "pg_catalog"
ALTER TABLE new_system_table RENAME TO old_system_table;
ALTER TABLE
CREATE INDEX old_system_table__othercol ON old_system_table (othercol);
CREATE INDEX
INSERT INTO old_system_table(othercol) VALUES ('somedata'), ('otherdata');
INSERT 0 2
UPDATE old_system_table SET id = -id;
UPDATE 2
DELETE FROM old_system_table WHERE othercol = 'somedata';
DELETE 1
TRUNCATE old_system_table;
TRUNCATE TABLE
ALTER TABLE old_system_table DROP CONSTRAINT new_system_table_pkey;
ALTER TABLE
ALTER TABLE old_system_table DROP COLUMN othercol;
ALTER TABLE
DROP TABLE old_system_table;
DROP TABLE
-- set logged
CREATE UNLOGGED TABLE unlogged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
CREATE TABLE
-- check relpersistence of an unlogged table
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
UNION ALL
SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'
UNION ALL
SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
ORDER BY relname;
     relname      | relkind | relpersistence 
------------------+---------+----------------
 toast index      | i       | u
 toast table      | t       | u
 unlogged1        | r       | u
 unlogged1_f1_seq | S       | p
 unlogged1_pkey   | i       | u
(5 rows)

CREATE UNLOGGED TABLE unlogged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged1); -- foreign key
CREATE TABLE
CREATE UNLOGGED TABLE unlogged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged3); -- self-referencing foreign key
CREATE TABLE
ALTER TABLE unlogged3 SET LOGGED; -- skip self-referencing foreign key
ALTER TABLE
ALTER TABLE unlogged2 SET LOGGED; -- fails because a foreign key to an unlogged table exists
ERROR:  42P16: could not change table "unlogged2" to logged because it references unlogged table "unlogged1"
ALTER TABLE unlogged1 SET LOGGED;
ALTER TABLE
-- check relpersistence of an unlogged table after changing to permanent
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
UNION ALL
SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'
UNION ALL
SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
ORDER BY relname;
     relname      | relkind | relpersistence 
------------------+---------+----------------
 toast index      | i       | p
 toast table      | t       | p
 unlogged1        | r       | p
 unlogged1_f1_seq | S       | p
 unlogged1_pkey   | i       | p
(5 rows)

ALTER TABLE unlogged1 SET LOGGED; -- silently do nothing
ALTER TABLE
DROP TABLE unlogged3;
DROP TABLE
DROP TABLE unlogged2;
DROP TABLE
DROP TABLE unlogged1;
DROP TABLE
-- set unlogged
CREATE TABLE logged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
CREATE TABLE
-- check relpersistence of a permanent table
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
UNION ALL
SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'
UNION ALL
SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
ORDER BY relname;
    relname     | relkind | relpersistence 
----------------+---------+----------------
 logged1        | r       | p
 logged1_f1_seq | S       | p
 logged1_pkey   | i       | p
 toast index    | i       | p
 toast table    | t       | p
(5 rows)

CREATE TABLE logged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged1); -- foreign key
CREATE TABLE
CREATE TABLE logged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged3); -- self-referencing foreign key
CREATE TABLE
ALTER TABLE logged1 SET UNLOGGED; -- fails because a foreign key from a permanent table exists
ERROR:  42P16: could not change table "logged1" to unlogged because it references logged table "logged2"
ALTER TABLE logged3 SET UNLOGGED; -- skip self-referencing foreign key
ALTER TABLE
ALTER TABLE logged2 SET UNLOGGED;
ALTER TABLE
ALTER TABLE logged1 SET UNLOGGED;
ALTER TABLE
-- check relpersistence of a permanent table after changing to unlogged
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
UNION ALL
SELECT 'toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'
UNION ALL
SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
ORDER BY relname;
    relname     | relkind | relpersistence 
----------------+---------+----------------
 logged1        | r       | u
 logged1_f1_seq | S       | p
 logged1_pkey   | i       | u
 toast index    | i       | u
 toast table    | t       | u
(5 rows)

ALTER TABLE logged1 SET UNLOGGED; -- silently do nothing
ALTER TABLE
DROP TABLE logged3;
DROP TABLE
DROP TABLE logged2;
DROP TABLE
DROP TABLE logged1;
DROP TABLE
