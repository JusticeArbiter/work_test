--
-- CREATE_INDEX
-- Create ancillary data structures (i.e. indices)
--
--
-- BTREE
--
CREATE INDEX onek_unique1 ON onek USING btree(unique1 int4_ops);
CREATE INDEX
CREATE INDEX IF NOT EXISTS onek_unique1 ON onek USING btree(unique1 int4_ops);
NOTICE:  42P07: relation "onek_unique1" already exists, skipping
CREATE INDEX
CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_ops);
ERROR:  42601: syntax error at or near "ON"
LINE 1: CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_...
                                   ^
CREATE INDEX onek_unique2 ON onek USING btree(unique2 int4_ops);
CREATE INDEX
CREATE INDEX onek_hundred ON onek USING btree(hundred int4_ops);
CREATE INDEX
CREATE INDEX onek_stringu1 ON onek USING btree(stringu1 name_ops);
CREATE INDEX
CREATE INDEX tenk1_unique1 ON tenk1 USING btree(unique1 int4_ops);
CREATE INDEX
CREATE INDEX tenk1_unique2 ON tenk1 USING btree(unique2 int4_ops);
CREATE INDEX
CREATE INDEX tenk1_hundred ON tenk1 USING btree(hundred int4_ops);
CREATE INDEX
CREATE INDEX tenk1_thous_tenthous ON tenk1 (thousand, tenthous);
CREATE INDEX
CREATE INDEX tenk2_unique1 ON tenk2 USING btree(unique1 int4_ops);
CREATE INDEX
CREATE INDEX tenk2_unique2 ON tenk2 USING btree(unique2 int4_ops);
CREATE INDEX
CREATE INDEX tenk2_hundred ON tenk2 USING btree(hundred int4_ops);
CREATE INDEX
CREATE INDEX rix ON road USING btree (name text_ops);
CREATE INDEX
CREATE INDEX iix ON ihighway USING btree (name text_ops);
CREATE INDEX
CREATE INDEX six ON shighway USING btree (name text_ops);
CREATE INDEX
-- test comments
COMMENT ON INDEX six_wrong IS 'bad index';
ERROR:  42P01: relation "six_wrong" does not exist
COMMENT ON INDEX six IS 'good index';
COMMENT
COMMENT ON INDEX six IS NULL;
COMMENT
--
-- BTREE ascending/descending cases
--
-- we load int4/text from pure descending data (each key is a new
-- low key) and name/f8 from pure ascending data (each key is a new
-- high key).  we had a bug where new low keys would sometimes be
-- "lost".
--
CREATE INDEX bt_i4_index ON bt_i4_heap USING btree (seqno int4_ops);
CREATE INDEX
CREATE INDEX bt_name_index ON bt_name_heap USING btree (seqno name_ops);
CREATE INDEX
CREATE INDEX bt_txt_index ON bt_txt_heap USING btree (seqno text_ops);
CREATE INDEX
CREATE INDEX bt_f8_index ON bt_f8_heap USING btree (seqno float8_ops);
CREATE INDEX
--
-- BTREE partial indices
--
CREATE INDEX onek2_u1_prtl ON onek2 USING btree(unique1 int4_ops)
	where unique1 < 20 or unique1 > 980;
CREATE INDEX
CREATE INDEX onek2_u2_prtl ON onek2 USING btree(unique2 int4_ops)
	where stringu1 < 'B';
CREATE INDEX
CREATE INDEX onek2_stu1_prtl ON onek2 USING btree(stringu1 name_ops)
	where onek2.stringu1 >= 'J' and onek2.stringu1 < 'K';
CREATE INDEX
--
-- GiST (rtree-equivalent opclasses only)
--
CREATE INDEX grect2ind ON fast_emp4000 USING gist (home_base);
CREATE INDEX
CREATE INDEX gpolygonind ON polygon_tbl USING gist (f1);
CREATE INDEX
CREATE INDEX gcircleind ON circle_tbl USING gist (f1);
CREATE INDEX
INSERT INTO POINT_TBL(f1) VALUES (NULL);
INSERT 0 1
CREATE INDEX gpointind ON point_tbl USING gist (f1);
CREATE INDEX
CREATE TEMP TABLE gpolygon_tbl AS
    SELECT polygon(home_base) AS f1 FROM slow_emp4000;
SELECT 0
INSERT INTO gpolygon_tbl VALUES ( '(1000,0,0,1000)' );
INSERT 0 1
INSERT INTO gpolygon_tbl VALUES ( '(0,1000,1000,1000)' );
INSERT 0 1
CREATE TEMP TABLE gcircle_tbl AS
    SELECT circle(home_base) AS f1 FROM slow_emp4000;
SELECT 0
CREATE INDEX ggpolygonind ON gpolygon_tbl USING gist (f1);
CREATE INDEX
CREATE INDEX ggcircleind ON gcircle_tbl USING gist (f1);
CREATE INDEX
--
-- SP-GiST
--
CREATE TABLE quad_point_tbl AS
    SELECT point(unique1,unique2) AS p FROM tenk1;
SELECT 0
INSERT INTO quad_point_tbl
    SELECT '(333.0,400.0)'::point FROM generate_series(1,1000);
INSERT 0 1000
INSERT INTO quad_point_tbl VALUES (NULL), (NULL), (NULL);
INSERT 0 3
CREATE INDEX sp_quad_ind ON quad_point_tbl USING spgist (p);
CREATE INDEX
CREATE TABLE kd_point_tbl AS SELECT * FROM quad_point_tbl;
SELECT 1003
CREATE INDEX sp_kd_ind ON kd_point_tbl USING spgist (p kd_point_ops);
CREATE INDEX
CREATE TABLE radix_text_tbl AS
    SELECT name AS t FROM road WHERE name !~ '^[0-9]';
SELECT 0
INSERT INTO radix_text_tbl
    SELECT 'P0123456789abcdef' FROM generate_series(1,1000);
INSERT 0 1000
INSERT INTO radix_text_tbl VALUES ('P0123456789abcde');
INSERT 0 1
INSERT INTO radix_text_tbl VALUES ('P0123456789abcdefF');
INSERT 0 1
CREATE INDEX sp_radix_ind ON radix_text_tbl USING spgist (t);
CREATE INDEX
--
-- Test GiST and SP-GiST indexes
--
-- get non-indexed results for comparison purposes
SET enable_seqscan = ON;
SET
SET enable_indexscan = OFF;
SET
SET enable_bitmapscan = OFF;
SET
SELECT * FROM fast_emp4000
    WHERE home_base @ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
 home_base 
-----------
(0 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
 count 
-------
     0
(1 row)

SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
 count 
-------
     0
(1 row)

SELECT * FROM polygon_tbl WHERE f1 ~ '((1,1),(2,2),(2,1))'::polygon
    ORDER BY (poly_center(f1))[0];
         f1          
---------------------
 ((2,0),(2,4),(0,0))
(1 row)

SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
    ORDER BY area(f1);
      f1       
---------------
 <(1,2),3>
 <(1,3),5>
 <(1,2),100>
 <(100,1),115>
(4 rows)

SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
 count 
-------
     2
(1 row)

SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
 count 
-------
     0
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
 count 
-------
     1
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
 count 
-------
     2
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 <^ '(0.0, 0.0)';
 count 
-------
     1
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 >^ '(0.0, 0.0)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
 count 
-------
     1
(1 row)

SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
     f1     
------------
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 
(7 rows)

SELECT * FROM point_tbl WHERE f1 IS NULL;
 f1 
----
 
(1 row)

SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
     f1     
------------
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
(6 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
   f1    
---------
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
(4 rows)

SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
 count 
-------
     3
(1 row)

SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM quad_point_tbl;
 count 
-------
  1003
(1 row)

SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
 count 
-------
  1000
(1 row)

SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
 count 
-------
  1000
(1 row)

SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
 count 
-------
     0
(1 row)

SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
 count 
-------
  1000
(1 row)

SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
 count 
-------
     0
(1 row)

SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
 count 
-------
     0
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
 count 
-------
  1000
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
 count 
-------
     1
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
 count 
-------
     1
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
 count 
-------
     0
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
 count 
-------
     0
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
 count 
-------
     0
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
 count 
-------
     0
(1 row)

SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
 count 
-------
     0
(1 row)

SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
           f1           
------------------------
 ((1000,0),(0,1000))
 ((0,1000),(1000,1000))
(2 rows)

SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 circle_center | radius 
---------------+--------
(0 rows)

-- Now check the results from plain indexscan
SET enable_seqscan = OFF;
SET
SET enable_indexscan = ON;
SET
SET enable_bitmapscan = OFF;
SET
EXPLAIN (COSTS OFF)
SELECT * FROM fast_emp4000
    WHERE home_base @ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort
   Sort Key: ((home_base[0])[0])
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base @ '(2000,1000),(200,200)'::box)
(4 rows)

SELECT * FROM fast_emp4000
    WHERE home_base @ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
 home_base 
-----------
(0 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base && '(1000,1000),(0,0)'::box)
(3 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base IS NULL)
(3 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM polygon_tbl WHERE f1 ~ '((1,1),(2,2),(2,1))'::polygon
    ORDER BY (poly_center(f1))[0];
                        QUERY PLAN                         
-----------------------------------------------------------
 Sort
   Sort Key: ((poly_center(f1))[0])
   ->  Index Scan using gpolygonind on polygon_tbl
         Index Cond: (f1 ~ '((1,1),(2,2),(2,1))'::polygon)
(4 rows)

SELECT * FROM polygon_tbl WHERE f1 ~ '((1,1),(2,2),(2,1))'::polygon
    ORDER BY (poly_center(f1))[0];
         f1          
---------------------
 ((2,0),(2,4),(0,0))
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
    ORDER BY area(f1);
                    QUERY PLAN                    
--------------------------------------------------
 Sort
   Sort Key: (area(f1))
   ->  Index Scan using gcircleind on circle_tbl
         Index Cond: (f1 && '<(1,-2),1>'::circle)
(4 rows)

SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
    ORDER BY area(f1);
      f1       
---------------
 <(1,2),3>
 <(1,3),5>
 <(1,2),100>
 <(100,1),115>
(4 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Index Scan using ggpolygonind on gpolygon_tbl
         Index Cond: (f1 && '((1000,1000),(0,0))'::polygon)
(3 rows)

SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Scan using ggcircleind on gcircle_tbl
         Index Cond: (f1 && '<(500,500),500>'::circle)
(3 rows)

SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '(100,100),(0,0)'::box)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '(100,100),(0,0)'::box)
(3 rows)

SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '((0,0),(0,100),(100,100),(50,50),(100,0),(0,0))'::polygon)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '<(50,50),50>'::circle)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 << '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 >> '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 <^ '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 <^ '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 <^ '(0.0, 0.0)';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 >^ '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 >^ '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 >^ '(0.0, 0.0)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 ~= '(-5,-12)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Order By: (f1 <-> '(0,1)'::point)
(2 rows)

SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
     f1     
------------
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 
(7 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NULL;
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 IS NULL)
(2 rows)

SELECT * FROM point_tbl WHERE f1 IS NULL;
 f1 
----
 
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 IS NOT NULL)
   Order By: (f1 <-> '(0,1)'::point)
(3 rows)

SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
     f1     
------------
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
(6 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
                   QUERY PLAN                   
------------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 <@ '(10,10),(-10,-10)'::box)
   Order By: (f1 <-> '(0,1)'::point)
(3 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
   f1    
---------
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
(4 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_quad_ind on quad_point_tbl
         Index Cond: (p IS NULL)
(3 rows)

SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_quad_ind on quad_point_tbl
         Index Cond: (p IS NOT NULL)
(3 rows)

SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl;
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_quad_ind on quad_point_tbl
(2 rows)

SELECT count(*) FROM quad_point_tbl;
 count 
-------
  1003
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_quad_ind on quad_point_tbl
         Index Cond: (p <@ '(1000,1000),(200,200)'::box)
(3 rows)

SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_quad_ind on quad_point_tbl
         Index Cond: (p <@ '(1000,1000),(200,200)'::box)
(3 rows)

SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_quad_ind on quad_point_tbl
         Index Cond: (p << '(5000,4000)'::point)
(3 rows)

SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_quad_ind on quad_point_tbl
         Index Cond: (p >> '(5000,4000)'::point)
(3 rows)

SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_quad_ind on quad_point_tbl
         Index Cond: (p <^ '(5000,4000)'::point)
(3 rows)

SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_quad_ind on quad_point_tbl
         Index Cond: (p >^ '(5000,4000)'::point)
(3 rows)

SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_quad_ind on quad_point_tbl
         Index Cond: (p ~= '(4585,365)'::point)
(3 rows)

SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
                       QUERY PLAN                        
---------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_kd_ind on kd_point_tbl
         Index Cond: (p <@ '(1000,1000),(200,200)'::box)
(3 rows)

SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
                       QUERY PLAN                        
---------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_kd_ind on kd_point_tbl
         Index Cond: (p <@ '(1000,1000),(200,200)'::box)
(3 rows)

SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_kd_ind on kd_point_tbl
         Index Cond: (p << '(5000,4000)'::point)
(3 rows)

SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_kd_ind on kd_point_tbl
         Index Cond: (p >> '(5000,4000)'::point)
(3 rows)

SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_kd_ind on kd_point_tbl
         Index Cond: (p <^ '(5000,4000)'::point)
(3 rows)

SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_kd_ind on kd_point_tbl
         Index Cond: (p >^ '(5000,4000)'::point)
(3 rows)

SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_kd_ind on kd_point_tbl
         Index Cond: (p ~= '(4585,365)'::point)
(3 rows)

SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t = 'P0123456789abcdef'::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t = 'P0123456789abcde'::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t = 'P0123456789abcdefF'::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
                              QUERY PLAN                              
----------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t < 'Aztec                         Ct  '::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
                               QUERY PLAN                               
------------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t ~<~ 'Aztec                         Ct  '::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t <= 'Aztec                         Ct  '::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t ~<=~ 'Aztec                         Ct  '::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
                              QUERY PLAN                              
----------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t = 'Aztec                         Ct  '::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
                              QUERY PLAN                              
----------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t = 'Worth                         St  '::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t >= 'Worth                         St  '::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t ~>=~ 'Worth                         St  '::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
                              QUERY PLAN                              
----------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t > 'Worth                         St  '::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
                               QUERY PLAN                               
------------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using sp_radix_ind on radix_text_tbl
         Index Cond: (t ~>~ 'Worth                         St  '::text)
(3 rows)

SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                     QUERY PLAN                      
-----------------------------------------------------
 Limit
   ->  Index Scan using ggpolygonind on gpolygon_tbl
         Order By: (f1 <-> '(0,0)'::point)
(3 rows)

SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
           f1           
------------------------
 ((1000,0),(0,1000))
 ((0,1000),(1000,1000))
(2 rows)

EXPLAIN (COSTS OFF)
SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
                    QUERY PLAN                     
---------------------------------------------------
 Limit
   ->  Index Scan using ggcircleind on gcircle_tbl
         Order By: (f1 <-> '(200,300)'::point)
(3 rows)

SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 circle_center | radius 
---------------+--------
(0 rows)

-- Now check the results from bitmap indexscan
SET enable_seqscan = OFF;
SET
SET enable_indexscan = OFF;
SET
SET enable_bitmapscan = ON;
SET
EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: ((f1 <-> '(0,1)'::point))
   ->  Bitmap Heap Scan on point_tbl
         Recheck Cond: (f1 <@ '(10,10),(-10,-10)'::box)
         ->  Bitmap Index Scan on gpointind
               Index Cond: (f1 <@ '(10,10),(-10,-10)'::box)
(6 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
   f1    
---------
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
(4 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
                  QUERY PLAN                  
----------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on quad_point_tbl
         Recheck Cond: (p IS NULL)
         ->  Bitmap Index Scan on sp_quad_ind
               Index Cond: (p IS NULL)
(5 rows)

SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
                  QUERY PLAN                  
----------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on quad_point_tbl
         Recheck Cond: (p IS NOT NULL)
         ->  Bitmap Index Scan on sp_quad_ind
               Index Cond: (p IS NOT NULL)
(5 rows)

SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl;
                  QUERY PLAN                  
----------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on quad_point_tbl
         ->  Bitmap Index Scan on sp_quad_ind
(3 rows)

SELECT count(*) FROM quad_point_tbl;
 count 
-------
  1003
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on quad_point_tbl
         Recheck Cond: (p <@ '(1000,1000),(200,200)'::box)
         ->  Bitmap Index Scan on sp_quad_ind
               Index Cond: (p <@ '(1000,1000),(200,200)'::box)
(5 rows)

SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on quad_point_tbl
         Recheck Cond: ('(1000,1000),(200,200)'::box @> p)
         ->  Bitmap Index Scan on sp_quad_ind
               Index Cond: ('(1000,1000),(200,200)'::box @> p)
(5 rows)

SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on quad_point_tbl
         Recheck Cond: (p << '(5000,4000)'::point)
         ->  Bitmap Index Scan on sp_quad_ind
               Index Cond: (p << '(5000,4000)'::point)
(5 rows)

SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on quad_point_tbl
         Recheck Cond: (p >> '(5000,4000)'::point)
         ->  Bitmap Index Scan on sp_quad_ind
               Index Cond: (p >> '(5000,4000)'::point)
(5 rows)

SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on quad_point_tbl
         Recheck Cond: (p <^ '(5000,4000)'::point)
         ->  Bitmap Index Scan on sp_quad_ind
               Index Cond: (p <^ '(5000,4000)'::point)
(5 rows)

SELECT count(*) FROM quad_point_tbl WHERE p <^ '(5000, 4000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on quad_point_tbl
         Recheck Cond: (p >^ '(5000,4000)'::point)
         ->  Bitmap Index Scan on sp_quad_ind
               Index Cond: (p >^ '(5000,4000)'::point)
(5 rows)

SELECT count(*) FROM quad_point_tbl WHERE p >^ '(5000, 4000)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on quad_point_tbl
         Recheck Cond: (p ~= '(4585,365)'::point)
         ->  Bitmap Index Scan on sp_quad_ind
               Index Cond: (p ~= '(4585,365)'::point)
(5 rows)

SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on kd_point_tbl
         Recheck Cond: (p <@ '(1000,1000),(200,200)'::box)
         ->  Bitmap Index Scan on sp_kd_ind
               Index Cond: (p <@ '(1000,1000),(200,200)'::box)
(5 rows)

SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on kd_point_tbl
         Recheck Cond: ('(1000,1000),(200,200)'::box @> p)
         ->  Bitmap Index Scan on sp_kd_ind
               Index Cond: ('(1000,1000),(200,200)'::box @> p)
(5 rows)

SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on kd_point_tbl
         Recheck Cond: (p << '(5000,4000)'::point)
         ->  Bitmap Index Scan on sp_kd_ind
               Index Cond: (p << '(5000,4000)'::point)
(5 rows)

SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on kd_point_tbl
         Recheck Cond: (p >> '(5000,4000)'::point)
         ->  Bitmap Index Scan on sp_kd_ind
               Index Cond: (p >> '(5000,4000)'::point)
(5 rows)

SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on kd_point_tbl
         Recheck Cond: (p <^ '(5000,4000)'::point)
         ->  Bitmap Index Scan on sp_kd_ind
               Index Cond: (p <^ '(5000,4000)'::point)
(5 rows)

SELECT count(*) FROM kd_point_tbl WHERE p <^ '(5000, 4000)';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on kd_point_tbl
         Recheck Cond: (p >^ '(5000,4000)'::point)
         ->  Bitmap Index Scan on sp_kd_ind
               Index Cond: (p >^ '(5000,4000)'::point)
(5 rows)

SELECT count(*) FROM kd_point_tbl WHERE p >^ '(5000, 4000)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on kd_point_tbl
         Recheck Cond: (p ~= '(4585,365)'::point)
         ->  Bitmap Index Scan on sp_kd_ind
               Index Cond: (p ~= '(4585,365)'::point)
(5 rows)

SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t = 'P0123456789abcdef'::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t = 'P0123456789abcdef'::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
 count 
-------
  1000
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
                        QUERY PLAN                        
----------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t = 'P0123456789abcde'::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t = 'P0123456789abcde'::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t = 'P0123456789abcdefF'::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t = 'P0123456789abcdefF'::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t < 'Aztec                         Ct  '::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t < 'Aztec                         Ct  '::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t ~<~ 'Aztec                         Ct  '::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t ~<~ 'Aztec                         Ct  '::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t <= 'Aztec                         Ct  '::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t <= 'Aztec                         Ct  '::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t ~<=~ 'Aztec                         Ct  '::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t ~<=~ 'Aztec                         Ct  '::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t = 'Aztec                         Ct  '::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t = 'Aztec                         Ct  '::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t = 'Worth                         St  '::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t = 'Worth                         St  '::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t >= 'Worth                         St  '::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t >= 'Worth                         St  '::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t ~>=~ 'Worth                         St  '::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t ~>=~ 'Worth                         St  '::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t > 'Worth                         St  '::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t > 'Worth                         St  '::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
 count 
-------
     0
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on radix_text_tbl
         Recheck Cond: (t ~>~ 'Worth                         St  '::text)
         ->  Bitmap Index Scan on sp_radix_ind
               Index Cond: (t ~>~ 'Worth                         St  '::text)
(5 rows)

SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
 count 
-------
     0
(1 row)

RESET enable_seqscan;
RESET
RESET enable_indexscan;
RESET
RESET enable_bitmapscan;
RESET
--
-- GIN over int[] and text[]
--
-- Note: GIN currently supports only bitmap scans, not plain indexscans
--
SET enable_seqscan = OFF;
SET
SET enable_indexscan = OFF;
SET
SET enable_bitmapscan = ON;
SET
CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
CREATE INDEX
explain (costs off)
SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
                     QUERY PLAN                     
----------------------------------------------------
 Sort
   Sort Key: seqno
   ->  Bitmap Heap Scan on array_index_op_test
         Recheck Cond: (i @> '{32}'::integer[])
         ->  Bitmap Index Scan on intarrayidx
               Index Cond: (i @> '{32}'::integer[])
(6 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_op_test WHERE i @> '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
CREATE INDEX
explain (costs off)
SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: seqno
   ->  Bitmap Heap Scan on array_index_op_test
         Recheck Cond: (t @> '{AAAAAAAA72908}'::text[])
         ->  Bitmap Index Scan on textarrayidx
               Index Cond: (t @> '{AAAAAAAA72908}'::text[])
(6 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

-- And try it with a multicolumn GIN index
DROP INDEX intarrayidx, textarrayidx;
DROP INDEX
CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
CREATE INDEX
SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

RESET enable_seqscan;
RESET
RESET enable_indexscan;
RESET
RESET enable_bitmapscan;
RESET
--
-- Try a GIN index with a lot of items with same key. (GIN creates a posting
-- tree when there are enough duplicates)
--
CREATE TABLE array_gin_test (a int[]);
CREATE TABLE
INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
INSERT 0 10000
CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
CREATE INDEX
SELECT COUNT(*) FROM array_gin_test WHERE a @> '{2}';
 count 
-------
  2000
(1 row)

DROP TABLE array_gin_test;
DROP TABLE
--
-- Test GIN index's reloptions
--
CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
  WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
CREATE INDEX
\d+ gin_relopts_test
     Index "public.gin_relopts_test"
 Column |  Type   | Definition | Storage 
--------+---------+------------+---------
 i      | integer | i          | plain
gin, for table "public.array_index_op_test"
Options: fastupdate=on, gin_pending_list_limit=128

--
-- HASH
--
CREATE INDEX hash_i4_index ON hash_i4_heap USING hash (random int4_ops);
WARNING:  01000: hash indexes are not WAL-logged and their use is discouraged
CREATE INDEX
CREATE INDEX hash_name_index ON hash_name_heap USING hash (random name_ops);
WARNING:  01000: hash indexes are not WAL-logged and their use is discouraged
CREATE INDEX
CREATE INDEX hash_txt_index ON hash_txt_heap USING hash (random text_ops);
WARNING:  01000: hash indexes are not WAL-logged and their use is discouraged
CREATE INDEX
CREATE INDEX hash_f8_index ON hash_f8_heap USING hash (random float8_ops);
WARNING:  01000: hash indexes are not WAL-logged and their use is discouraged
CREATE INDEX
CREATE UNLOGGED TABLE unlogged_hash_table (id int4);
CREATE TABLE
CREATE INDEX unlogged_hash_index ON unlogged_hash_table USING hash (id int4_ops);
CREATE INDEX
DROP TABLE unlogged_hash_table;
DROP TABLE
-- CREATE INDEX hash_ovfl_index ON hash_ovfl_heap USING hash (x int4_ops);
--
-- Test functional index
--
CREATE TABLE func_index_heap (f1 text, f2 text);
CREATE TABLE
CREATE UNIQUE INDEX func_index_index on func_index_heap (textcat(f1,f2));
CREATE INDEX
INSERT INTO func_index_heap VALUES('ABC','DEF');
INSERT 0 1
INSERT INTO func_index_heap VALUES('AB','CDEFG');
INSERT 0 1
INSERT INTO func_index_heap VALUES('QWE','RTY');
INSERT 0 1
-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
ERROR:  23505: duplicate key value violates unique constraint "func_index_index"
DETAIL:  Key (textcat(f1, f2))=(ABCDEF) already exists.
-- but this shouldn't:
INSERT INTO func_index_heap VALUES('QWERTY');
INSERT 0 1
--
-- Same test, expressional index
--
DROP TABLE func_index_heap;
DROP TABLE
CREATE TABLE func_index_heap (f1 text, f2 text);
CREATE TABLE
CREATE UNIQUE INDEX func_index_index on func_index_heap ((f1 || f2) text_ops);
CREATE INDEX
INSERT INTO func_index_heap VALUES('ABC','DEF');
INSERT 0 1
INSERT INTO func_index_heap VALUES('AB','CDEFG');
INSERT 0 1
INSERT INTO func_index_heap VALUES('QWE','RTY');
INSERT 0 1
-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
ERROR:  23505: duplicate key value violates unique constraint "func_index_index"
DETAIL:  Key ((f1 || f2))=(ABCDEF) already exists.
-- but this shouldn't:
INSERT INTO func_index_heap VALUES('QWERTY');
INSERT 0 1
--
-- Also try building functional, expressional, and partial indexes on
-- tables that already contain data.
--
create unique index hash_f8_index_1 on hash_f8_heap(abs(random));
CREATE INDEX
create unique index hash_f8_index_2 on hash_f8_heap((seqno + 1), random);
CREATE INDEX
create unique index hash_f8_index_3 on hash_f8_heap(random) where seqno > 1000;
CREATE INDEX
--
-- Try some concurrent index builds
--
-- Unfortunately this only tests about half the code paths because there are
-- no concurrent updates happening to the table at the same time.
CREATE TABLE concur_heap (f1 text, f2 text);
CREATE TABLE
-- empty table
CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
CREATE INDEX
CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
NOTICE:  42P07: relation "concur_index1" already exists, skipping
CREATE INDEX
INSERT INTO concur_heap VALUES  ('a','b');
INSERT 0 1
INSERT INTO concur_heap VALUES  ('b','b');
INSERT 0 1
-- unique index
CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
CREATE INDEX
CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
NOTICE:  42P07: relation "concur_index2" already exists, skipping
CREATE INDEX
-- check if constraint is set up properly to be enforced
INSERT INTO concur_heap VALUES ('b','x');
ERROR:  23505: duplicate key value violates unique constraint "concur_index2"
DETAIL:  Key (f1)=(b) already exists.
-- check if constraint is enforced properly at build time
CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
ERROR:  23505: could not create unique index "concur_index3"
DETAIL:  Key (f2)=(b) is duplicated.
-- test that expression indexes and partial indexes work concurrently
CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
CREATE INDEX
CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
CREATE INDEX
-- here we also check that you can default the index name
CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
CREATE INDEX
-- You can't do a concurrent index build in a transaction
BEGIN;
BEGIN
CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
ERROR:  25001: CREATE INDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
ROLLBACK
-- But you can do a regular index build in a transaction
BEGIN;
BEGIN
CREATE INDEX std_index on concur_heap(f2);
CREATE INDEX
COMMIT;
COMMIT
-- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
VACUUM FULL concur_heap;
VACUUM
REINDEX TABLE concur_heap;
ERROR:  23505: could not create unique index "concur_index3"
DETAIL:  Key (f2)=(b) is duplicated.
DELETE FROM concur_heap WHERE f1 = 'b';
DELETE 1
VACUUM FULL concur_heap;
VACUUM
\d concur_heap
Table "public.concur_heap"
 Column | Type | Modifiers 
--------+------+-----------
 f1     | text | 
 f2     | text | 
Indexes:
    "concur_index2" UNIQUE, btree (f1)
    "concur_index3" UNIQUE, btree (f2) INVALID
    "concur_heap_expr_idx" btree ((f2 || f1))
    "concur_index1" btree (f2, f1)
    "concur_index4" btree (f2) WHERE f1 = 'a'::text
    "concur_index5" btree (f2) WHERE f1 = 'x'::text
    "std_index" btree (f2)

REINDEX TABLE concur_heap;
REINDEX
\d concur_heap
Table "public.concur_heap"
 Column | Type | Modifiers 
--------+------+-----------
 f1     | text | 
 f2     | text | 
Indexes:
    "concur_index2" UNIQUE, btree (f1)
    "concur_index3" UNIQUE, btree (f2)
    "concur_heap_expr_idx" btree ((f2 || f1))
    "concur_index1" btree (f2, f1)
    "concur_index4" btree (f2) WHERE f1 = 'a'::text
    "concur_index5" btree (f2) WHERE f1 = 'x'::text
    "std_index" btree (f2)

--
-- Try some concurrent index drops
--
DROP INDEX CONCURRENTLY "concur_index2";				-- works
DROP INDEX
DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
NOTICE:  00000: index "concur_index2" does not exist, skipping
DROP INDEX
-- failures
DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
ERROR:  0A000: DROP INDEX CONCURRENTLY does not support dropping multiple objects
BEGIN;
BEGIN
DROP INDEX CONCURRENTLY "concur_index5";
ERROR:  25001: DROP INDEX CONCURRENTLY cannot run inside a transaction block
ROLLBACK;
ROLLBACK
-- successes
DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
DROP INDEX
DROP INDEX CONCURRENTLY "concur_index4";
DROP INDEX
DROP INDEX CONCURRENTLY "concur_index5";
DROP INDEX
DROP INDEX CONCURRENTLY "concur_index1";
DROP INDEX
DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
DROP INDEX
\d concur_heap
Table "public.concur_heap"
 Column | Type | Modifiers 
--------+------+-----------
 f1     | text | 
 f2     | text | 
Indexes:
    "std_index" btree (f2)

DROP TABLE concur_heap;
DROP TABLE
--
-- Test ADD CONSTRAINT USING INDEX
--
CREATE TABLE cwi_test( a int , b varchar(10), c char);
CREATE TABLE
-- add some data so that all tests have something to work with.
INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
INSERT 0 3
CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
CREATE INDEX
ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
ALTER TABLE
\d cwi_test
          Table "public.cwi_test"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 a      | integer               | not null
 b      | character varying(10) | not null
 c      | character(1)          | 
Indexes:
    "cwi_uniq_idx" PRIMARY KEY, btree (a, b)

\d cwi_uniq_idx
         Index "public.cwi_uniq_idx"
 Column |         Type          | Definition 
--------+-----------------------+------------
 a      | integer               | a
 b      | character varying(10) | b
primary key, btree, for table "public.cwi_test"

CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
CREATE INDEX
ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
		USING INDEX cwi_uniq2_idx;
NOTICE:  00000: ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "cwi_uniq2_idx" to "cwi_replaced_pkey"
ALTER TABLE
\d cwi_test
          Table "public.cwi_test"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 a      | integer               | not null
 b      | character varying(10) | not null
 c      | character(1)          | 
Indexes:
    "cwi_replaced_pkey" PRIMARY KEY, btree (b, a)

\d cwi_replaced_pkey
      Index "public.cwi_replaced_pkey"
 Column |         Type          | Definition 
--------+-----------------------+------------
 b      | character varying(10) | b
 a      | integer               | a
primary key, btree, for table "public.cwi_test"

DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on it
ERROR:  2BP01: cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
DROP TABLE cwi_test;
DROP TABLE
--
-- Tests for IS NULL/IS NOT NULL with b-tree indexes
--
SELECT unique1, unique2 INTO onek_with_null FROM onek;
SELECT 0
INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
INSERT 0 2
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2,unique1);
CREATE INDEX
SET enable_seqscan = OFF;
SET
SET enable_indexscan = ON;
SET
SET enable_bitmapscan = ON;
SET
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
     0
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
DROP INDEX
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc,unique1);
CREATE INDEX
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
     0
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
DROP INDEX
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
CREATE INDEX
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
     0
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
DROP INDEX
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
CREATE INDEX
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
     0
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
DROP INDEX
-- Check initial-positioning logic too
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2);
CREATE INDEX
SET enable_seqscan = OFF;
SET
SET enable_indexscan = ON;
SET
SET enable_bitmapscan = OFF;
SET
SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
         |        
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
(1 row)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
(0 rows)

SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
         |        
         |      -1
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
(1 row)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
(1 row)

RESET enable_seqscan;
RESET
RESET enable_indexscan;
RESET
RESET enable_bitmapscan;
RESET
DROP TABLE onek_with_null;
DROP TABLE
--
-- Check bitmap index path planning
--
EXPLAIN (COSTS OFF)
SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
                           QUERY PLAN                            
-----------------------------------------------------------------
 Bitmap Heap Scan on tenk1
   Recheck Cond: (thousand = 42)
   Filter: ((tenthous = 1) OR (tenthous = 3) OR (tenthous = 42))
   ->  Bitmap Index Scan on tenk1_thous_tenthous
         Index Cond: (thousand = 42)
(5 rows)

SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
(0 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on tenk1
         Recheck Cond: (hundred = 42)
         Filter: ((thousand = 42) OR (thousand = 99))
         ->  Bitmap Index Scan on tenk1_hundred
               Index Cond: (hundred = 42)
(6 rows)

SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
 count 
-------
     0
(1 row)

--
-- Check behavior with duplicate index column contents
--
CREATE TABLE dupindexcols AS
  SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
SELECT 0
CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
CREATE INDEX
ANALYZE dupindexcols;
ANALYZE
EXPLAIN (COSTS OFF)
  SELECT count(*) FROM dupindexcols
    WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on dupindexcols
         Recheck Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
         ->  Bitmap Index Scan on dupindexcols_i
               Index Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
(5 rows)

SELECT count(*) FROM dupindexcols
  WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
 count 
-------
     0
(1 row)

--
-- Check ordering of =ANY indexqual results (bug in 9.2.0)
--
vacuum tenk1;		-- ensure we get consistent plans here
VACUUM
explain (costs off)
SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Sort
   Sort Key: unique1
   ->  Bitmap Heap Scan on tenk1
         Recheck Cond: (unique1 = ANY ('{1,42,7}'::integer[]))
         ->  Bitmap Index Scan on tenk1_unique1
               Index Cond: (unique1 = ANY ('{1,42,7}'::integer[]))
(6 rows)

SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
 unique1 
---------
(0 rows)

explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort
   Sort Key: thousand
   ->  Index Only Scan using tenk1_thous_tenthous on tenk1
         Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
(4 rows)

SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
 thousand | tenthous 
----------+----------
(0 rows)

SET enable_indexonlyscan = OFF;
SET
explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort
   Sort Key: thousand
   ->  Index Scan using tenk1_thous_tenthous on tenk1
         Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
(4 rows)

SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
 thousand | tenthous 
----------+----------
(0 rows)

RESET enable_indexonlyscan;
RESET
--
-- Check elimination of constant-NULL subexpressions
--
explain (costs off)
  select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
                      QUERY PLAN                      
------------------------------------------------------
 Index Scan using tenk1_thous_tenthous on tenk1
   Index Cond: ((thousand = 1) AND (tenthous = 1001))
(2 rows)

--
-- REINDEX (VERBOSE)
--
CREATE TABLE reindex_verbose(id integer primary key);
CREATE TABLE
\set VERBOSITY terse
REINDEX (VERBOSE) TABLE reindex_verbose;
INFO:  00000: index "reindex_verbose_pkey" was reindexed
REINDEX
DROP TABLE reindex_verbose;
DROP TABLE
--
-- REINDEX SCHEMA
--
REINDEX SCHEMA schema_to_reindex; -- failure, schema does not exist
ERROR:  3F000: schema "schema_to_reindex" does not exist
CREATE SCHEMA schema_to_reindex;
CREATE SCHEMA
SET search_path = 'schema_to_reindex';
SET
CREATE TABLE table1(col1 SERIAL PRIMARY KEY);
CREATE TABLE
INSERT INTO table1 SELECT generate_series(1,400);
INSERT 0 400
CREATE TABLE table2(col1 SERIAL PRIMARY KEY, col2 TEXT NOT NULL);
CREATE TABLE
INSERT INTO table2 SELECT generate_series(1,400), 'abc';
INSERT 0 400
CREATE INDEX ON table2(col2);
CREATE INDEX
CREATE MATERIALIZED VIEW matview AS SELECT col1 FROM table2;
SELECT 400
CREATE INDEX ON matview(col1);
CREATE INDEX
CREATE VIEW view AS SELECT col2 FROM table2;
CREATE VIEW
CREATE TABLE reindex_before AS
SELECT oid, relname, relfilenode, relkind, reltoastrelid
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
SELECT 10
INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE', relfilenode, relkind, reltoastrelid
FROM pg_class WHERE oid IN
	(SELECT reltoastrelid FROM reindex_before WHERE reltoastrelid > 0);
INSERT 0 1
INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE_index', relfilenode, relkind, reltoastrelid
FROM pg_class where oid in
	(select indexrelid from pg_index where indrelid in
		(select reltoastrelid from reindex_before where reltoastrelid > 0));
INSERT 0 1
REINDEX SCHEMA schema_to_reindex;
REINDEX
CREATE TABLE reindex_after AS SELECT oid, relname, relfilenode, relkind
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
SELECT 11
SELECT  b.relname,
        b.relkind,
        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
        ELSE 'relfilenode has changed' END
  FROM reindex_before b JOIN pg_class a ON b.oid = a.oid
  ORDER BY 1;
       relname        | relkind |           case           
----------------------+---------+--------------------------
 matview              | m       | relfilenode is unchanged
 matview_col1_idx     | i       | relfilenode has changed
 pg_toast_TABLE       | t       | relfilenode is unchanged
 pg_toast_TABLE_index | i       | relfilenode has changed
 table1               | r       | relfilenode is unchanged
 table1_col1_seq      | S       | relfilenode is unchanged
 table1_pkey          | i       | relfilenode has changed
 table2               | r       | relfilenode is unchanged
 table2_col1_seq      | S       | relfilenode is unchanged
 table2_col2_idx      | i       | relfilenode has changed
 table2_pkey          | i       | relfilenode has changed
 view                 | v       | relfilenode is unchanged
(12 rows)

REINDEX SCHEMA schema_to_reindex;
REINDEX
BEGIN;
BEGIN
REINDEX SCHEMA schema_to_reindex; -- failure, cannot run in a transaction
ERROR:  25001: REINDEX SCHEMA cannot run inside a transaction block
END;
ROLLBACK
-- Failure for unauthorized user
CREATE ROLE regression_reindexuser NOLOGIN;
CREATE ROLE
SET SESSION ROLE regression_reindexuser;
SET
REINDEX SCHEMA schema_to_reindex;
ERROR:  42501: must be owner of schema schema_to_reindex
-- Clean up
RESET ROLE;
RESET
DROP ROLE regression_reindexuser;
DROP ROLE
SET client_min_messages TO 'warning';
SET
DROP SCHEMA schema_to_reindex CASCADE;
DROP SCHEMA
RESET client_min_messages;
RESET
